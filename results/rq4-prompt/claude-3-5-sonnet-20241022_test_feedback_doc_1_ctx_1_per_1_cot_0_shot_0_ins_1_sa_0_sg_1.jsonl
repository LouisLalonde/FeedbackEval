{"_id": "62e60ed4d76274f8a4026da0", "fixed_results": [], "level": "class_runnable", "oracle_context": "{ \"apis\" : \"['list']\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": "Return the keys of the record.\n\n:return: list of key names", "correct_code": "    def keys(self):\n        \"\"\" Return the keys of the record.\n\n        :return: list of key names\n        \"\"\"\n        return list(self.__keys)\n"}
{"_id": "62e60ecfd76274f8a4026d6a", "fixed_results": [{"source": "existing", "false_code": "def protocol_handlers(cls, protocol_version=None):\n    if protocol_version is None:\n        return None\n    elif protocol_version == 1:\n        return BoltProtocolHandlerV1()\n    elif protocol_version == 2:\n        return BoltProtocolHandlerV2()\n    elif protocol_version == 3:\n        return BoltProtocolHandlerV3()\n    else:\n        raise ValueError(\"Invalid protocol version\")", "fixed_code": "def protocol_handlers(cls, protocol_version=None):\n    if protocol_version is not None and not isinstance(protocol_version, tuple):\n        raise TypeError(\"Protocol version must be a tuple\")\n        \n    handlers = {\n        (1, 0): BoltProtocolHandlerV1(),\n        (2, 0): BoltProtocolHandlerV2(),\n        (3, 0): BoltProtocolHandlerV3()\n    }\n    \n    if protocol_version is None:\n        return handlers\n    \n    return {k: v for k, v in handlers.items() if k == protocol_version}"}], "level": "project_runnable", "oracle_context": "{ \"apis\" : \"['isinstance']\", \"classes\" : \"['Bolt3', 'TypeError']\", \"vars\" : \"[]\" }", "docstring": "Return a dictionary of available Bolt protocol handlers,\nkeyed by version tuple. If an explicit protocol version is\nprovided, the dictionary will contain either zero or one items,\ndepending on whether that version is supported. If no protocol\nversion is provided, all available versions will be returned.\n\n:param protocol_version: tuple identifying a specific protocol\n    version (e.g. (3, 5)) or None\n:return: dictionary of version tuple to handler class for all\n    relevant and supported protocol versions\n:raise TypeError: if protocol version is not passed in a tuple", "correct_code": "    @classmethod\n    def protocol_handlers(cls, protocol_version=None):\n        \"\"\" Return a dictionary of available Bolt protocol handlers,\n        keyed by version tuple. If an explicit protocol version is\n        provided, the dictionary will contain either zero or one items,\n        depending on whether that version is supported. If no protocol\n        version is provided, all available versions will be returned.\n\n        :param protocol_version: tuple identifying a specific protocol\n            version (e.g. (3, 5)) or None\n        :return: dictionary of version tuple to handler class for all\n            relevant and supported protocol versions\n        :raise TypeError: if protocol version is not passed in a tuple\n        \"\"\"\n\n        # Carry out Bolt subclass imports locally to avoid circular dependency issues.\n        from ._bolt3 import Bolt3\n        from ._bolt4 import (\n            Bolt4x1,\n            Bolt4x2,\n            Bolt4x3,\n            Bolt4x4,\n        )\n        from ._bolt5 import Bolt5x0\n\n        handlers = {\n            Bolt3.PROTOCOL_VERSION: Bolt3,\n            # 4.0 unsupported because no space left in the handshake\n            Bolt4x1.PROTOCOL_VERSION: Bolt4x1,\n            Bolt4x2.PROTOCOL_VERSION: Bolt4x2,\n            Bolt4x3.PROTOCOL_VERSION: Bolt4x3,\n            Bolt4x4.PROTOCOL_VERSION: Bolt4x4,\n            Bolt5x0.PROTOCOL_VERSION: Bolt5x0,\n        }\n\n        if protocol_version is None:\n            return handlers\n\n        if not isinstance(protocol_version, tuple):\n            raise TypeError(\"Protocol version must be specified as a tuple\")\n\n        if protocol_version in handlers:\n            return {protocol_version: handlers[protocol_version]}\n\n        return {}\n"}
{"_id": "62e60e05d76274f8a4026cfd", "fixed_results": [{"source": "rule_based", "false_code": "def index(self, key):\n    \"\"\" Return the index of the given item.\n\n    :param key: a key\n    :return: index\n    :rtype: int\n    \"\"\"\n    if isinstance(key, int):\n        if 1 <= key < len(self.__keys):\n            return key\n        raise IndexError(key)\n    elif isinstance(key, str):\n        try:\n            return self.__keys.index(key)\n        except ValueError:\n            raise KeyError(key)\n    else:\n        raise TypeError(key)\n", "fixed_code": "def index(self, key):\n    \"\"\" Return the index of the given item.\n\n    :param key: a key\n    :return: index\n    :rtype: int\n    \"\"\"\n    if isinstance(key, int):\n        if 0 <= key <= len(self.__keys) - 1:\n            return key\n        raise IndexError(key)\n    elif isinstance(key, str):\n        try:\n            return self.__keys.index(key)\n        except ValueError:\n            raise KeyError(key)\n    else:\n        raise TypeError(key)"}], "level": "class_runnable", "oracle_context": "{ \"apis\" : \"['isinstance', 'len']\", \"classes\" : \"['IndexError', 'TypeError', 'KeyError']\", \"vars\" : \"[]\" }", "docstring": "Return the index of the given item.\n\n:param key: a key\n:return: index\n:rtype: int", "correct_code": "    def index(self, key):\n        \"\"\" Return the index of the given item.\n\n        :param key: a key\n        :return: index\n        :rtype: int\n        \"\"\"\n        if isinstance(key, int):\n            if 0 <= key < len(self.__keys):\n                return key\n            raise IndexError(key)\n        elif isinstance(key, str):\n            try:\n                return self.__keys.index(key)\n            except ValueError:\n                raise KeyError(key)\n        else:\n            raise TypeError(key)\n"}
{"_id": "62e60da4d76274f8a4026cf1", "fixed_results": [{"source": "existing", "false_code": "def values(self, *keys):\n    return [self.index[key] for key in keys]", "fixed_code": "def values(self, *keys):\n    if not keys:\n        return list(self.index.values())\n    return [self.index[key] for key in keys]"}], "level": "class_runnable", "oracle_context": "{ \"apis\" : \"['index', 'keys', 'list', 'append']\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": "Return the values of the record, optionally filtering to\ninclude only certain values by index or key.\n\n:param keys: indexes or keys of the items to include; if none\n             are provided, all values will be included\n:return: list of values\n:rtype: list", "correct_code": "    def values(self, *keys):\n        \"\"\" Return the values of the record, optionally filtering to\n        include only certain values by index or key.\n\n        :param keys: indexes or keys of the items to include; if none\n                     are provided, all values will be included\n        :return: list of values\n        :rtype: list\n        \"\"\"\n        if keys:\n            d = []\n            for key in keys:\n                try:\n                    i = self.index(key)\n                except KeyError:\n                    d.append(None)\n                else:\n                    d.append(self[i])\n            return d\n        return list(self)\n"}
{"_id": "62e60b10d76274f8a4026ccd", "fixed_results": [{"source": "existing", "false_code": "def data(self, *keys):\n    \"\"\"\n    Returns the keys processed by the transform method of the RecordExporter class.\n    \n    Parameters:\n    - self: The instance of the RecordExporter class.\n    - *keys: Variable number of keys to be processed by the transform method.\n    \n    Returns:\n    - A list of keys processed by the transform method.\n    \"\"\"\n    pass", "fixed_code": "def data(self, *keys):\n    \"\"\"\n    Return the keys and values of this record as a dictionary,\n    optionally including only certain values by index or key. Keys\n    provided in the items that are not in the record will be\n    inserted with a value of :const:`None`; indexes provided\n    that are out of bounds will trigger an :exc:`IndexError`.\n\n    :param keys: indexes or keys of the items to include; if none\n                  are provided, all values will be included\n    :return: dictionary of values, keyed by field name\n    :raises: :exc:`IndexError` if an out-of-bounds index is specified\n    \"\"\"\n    # Get all items as a dictionary\n    result = dict(self.items())\n    \n    # If no keys specified, return all items\n    if not keys:\n        return result\n        \n    # Handle both index and key-based access\n    output = {}\n    for key in keys:\n        if isinstance(key, int):\n            # Handle index-based access\n            if key >= len(result):\n                raise IndexError(f\"Index {key} is out of bounds\")\n            field_name = list(result.keys())[key]\n            output[field_name] = result[field_name]\n        else:\n            # Handle key-based access\n            output[key] = result.get(key, None)\n            \n    return output"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['keys', 'transform', 'dict', 'items']\", \"classes\" : \"['RecordExporter']\", \"vars\" : \"['RecordExporter']\" }", "docstring": "Return the keys and values of this record as a dictionary,\noptionally including only certain values by index or key. Keys\nprovided in the items that are not in the record will be\ninserted with a value of :const:`None`; indexes provided\nthat are out of bounds will trigger an :exc:`IndexError`.\n\n:param keys: indexes or keys of the items to include; if none\n              are provided, all values will be included\n:return: dictionary of values, keyed by field name\n:raises: :exc:`IndexError` if an out-of-bounds index is specified", "correct_code": "    def data(self, *keys):\n        \"\"\" Return the keys and values of this record as a dictionary,\n        optionally including only certain values by index or key. Keys\n        provided in the items that are not in the record will be\n        inserted with a value of :const:`None`; indexes provided\n        that are out of bounds will trigger an :exc:`IndexError`.\n\n        :param keys: indexes or keys of the items to include; if none\n                      are provided, all values will be included\n        :return: dictionary of values, keyed by field name\n        :raises: :exc:`IndexError` if an out-of-bounds index is specified\n        \"\"\"\n        return RecordExporter().transform(dict(self.items(*keys)))\n"}
{"_id": "62e60879d76274f8a4026bec", "fixed_results": [{"source": "existing", "false_code": "def begin(self, mode=None, bookmarks=None, metadata=None, timeout=None, db=None, imp_user=None, dehydration_hooks=None, hydration_hooks=None, **handlers):\n    pass", "fixed_code": "def begin(self, mode=None, bookmarks=None, metadata=None, timeout=None, db=None, imp_user=None, dehydration_hooks=None, hydration_hooks=None, **handlers):\n    # Validate mode parameter\n    if mode is not None and mode not in (\"READ\", \"WRITE\"):\n        raise ValueError(\"Mode must be 'READ' or 'WRITE'\")\n    \n    # Validate timeout parameter\n    if timeout is not None:\n        if not isinstance(timeout, (int, float)):\n            raise TypeError(\"Timeout must be a number\")\n        if timeout < 0:\n            raise ValueError(\"Timeout cannot be negative\")\n    \n    # Construct the BEGIN message\n    message = {\n        \"mode\": \"WRITE\" if mode is None else mode,\n        \"bookmarks\": list(bookmarks) if bookmarks else [],\n        \"tx_metadata\": metadata or {},\n        \"timeout\": int(timeout * 1000) if timeout is not None else None,\n    }\n    \n    # Add optional parameters if provided\n    if db is not None:\n        message[\"db\"] = db\n    if imp_user is not None:\n        message[\"imp_user\"] = imp_user\n    \n    # Append BEGIN message to output queue\n    self._append((\"BEGIN\", message))\n    \n    # Create and return Response object with handlers and hooks\n    return Response(\n        handlers,\n        dehydration_hooks=dehydration_hooks,\n        hydration_hooks=hydration_hooks\n    )"}], "level": "project_runnable", "oracle_context": "{ \"apis\" : \"['_append', 'debug', 'format', 'list', 'dict', 'float', 'int']\", \"classes\" : \"['ConfigurationError', 'READ_ACCESS', 'Response', 'ValueError', 'TypeError']\", \"vars\" : \"['Str', 'log']\" }", "docstring": "Appends a BEGIN message to the output queue.\n\n:param mode: access mode for routing - \"READ\" or \"WRITE\" (default)\n:param bookmarks: iterable of bookmark values after which this transaction should begin\n:param metadata: custom metadata dictionary to attach to the transaction\n:param timeout: timeout for transaction execution (seconds)\n:param db: name of the database against which to begin the transaction\n    Requires Bolt 4.0+.\n:param imp_user: the user to impersonate\n    Requires Bolt 4.4+\n:param dehydration_hooks:\n    Hooks to dehydrate types (dict from type (class) to dehydration\n    function). Dehydration functions receive the value and returns an\n    object of type understood by packstream.\n:param hydration_hooks:\n    Hooks to hydrate types (mapping from type (class) to\n    dehydration function). Dehydration functions receive the value of\n    type understood by packstream and are free to return anything.\n:param handlers: handler functions passed into the returned Response object\n:return: Response object", "correct_code": "    def begin(self, mode=None, bookmarks=None, metadata=None, timeout=None,\n              db=None, imp_user=None, dehydration_hooks=None,\n              hydration_hooks=None, **handlers):\n        if db is not None:\n            raise ConfigurationError(\n                \"Database name parameter for selecting database is not \"\n                \"supported in Bolt Protocol {!r}. Database name {!r}.\".format(\n                    self.PROTOCOL_VERSION, db\n                )\n            )\n        if imp_user is not None:\n            raise ConfigurationError(\n                \"Impersonation is not supported in Bolt Protocol {!r}. \"\n                \"Trying to impersonate {!r}.\".format(\n                    self.PROTOCOL_VERSION, imp_user\n                )\n            )\n        extra = {}\n        if mode in (READ_ACCESS, \"r\"):\n            extra[\"mode\"] = \"r\"  # It will default to mode \"w\" if nothing is specified\n        if bookmarks:\n            try:\n                extra[\"bookmarks\"] = list(bookmarks)\n            except TypeError:\n                raise TypeError(\"Bookmarks must be provided within an iterable\")\n        if metadata:\n            try:\n                extra[\"tx_metadata\"] = dict(metadata)\n            except TypeError:\n                raise TypeError(\"Metadata must be coercible to a dict\")\n        if timeout is not None:\n            try:\n                extra[\"tx_timeout\"] = int(1000 * float(timeout))\n            except TypeError:\n                raise TypeError(\"Timeout must be specified as a number of seconds\")\n            if extra[\"tx_timeout\"] < 0:\n                raise ValueError(\"Timeout must be a positive number or 0.\")\n        log.debug(\"[#%04X]  C: BEGIN %r\", self.local_port, extra)\n        self._append(b\"\\x11\", (extra,),\n                     Response(self, \"begin\", hydration_hooks, **handlers),\n                     dehydration_hooks=dehydration_hooks)\n"}
{"_id": "62e60723d76274f8a4026b75", "fixed_results": [], "level": "self_contained", "oracle_context": "{ \"apis\" : \"['int', 'round']\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": ">>> round_half_to_even(3)\n    3\n    >>> round_half_to_even(3.2)\n    3\n    >>> round_half_to_even(3.5)\n    4\n    >>> round_half_to_even(3.7)\n    4\n    >>> round_half_to_even(4)\n    4\n    >>> round_half_to_even(4.2)\n    4\n    >>> round_half_to_even(4.5)\n    4\n    >>> round_half_to_even(4.7)\n    5\n\n:param n:\n:return:", "correct_code": "def round_half_to_even(n):\n    \"\"\"\n\n        >>> round_half_to_even(3)\n        3\n        >>> round_half_to_even(3.2)\n        3\n        >>> round_half_to_even(3.5)\n        4\n        >>> round_half_to_even(3.7)\n        4\n        >>> round_half_to_even(4)\n        4\n        >>> round_half_to_even(4.2)\n        4\n        >>> round_half_to_even(4.5)\n        4\n        >>> round_half_to_even(4.7)\n        5\n\n    :param n:\n    :return:\n    \"\"\"\n    ten_n = 10 * n\n    if ten_n == int(ten_n) and ten_n % 10 == 5:\n        up = int(n + 0.5)\n        down = int(n - 0.5)\n        return up if up % 2 == 0 else down\n    else:\n        return int(round(n))\n"}
{"_id": "62e4fc3c85ea98643089041e", "fixed_results": [{"source": "existing", "false_code": "def _inline_r_setup(code: str) -> str:\n    return \"\"\"\nsome_behaviour <- function() {\n    # Some behaviour of R cannot be configured via env variables, but can only be configured via R options once R has started. These are set here.\n    # Code goes here\n}\nsome_behaviour()\n\"\"\"", "fixed_code": "def _inline_r_setup(code: str) -> str:\n    return \"\"\"\nsome_behaviour <- function() {\n    # Some behaviour of R cannot be configured via env variables, but can only be configured via R options once R has started\n    options(warn = 1)  # Show warnings as they occur\n    options(stringsAsFactors = FALSE)  # Prevent automatic conversion of strings to factors\n    options(width = 80)  # Set output width\n    options(encoding = \"UTF-8\")  # Set default encoding\n    options(scipen = 10)  # Control scientific notation\n    options(digits = 7)  # Set significant digits for numeric display\n}\nsome_behaviour()\n\"\"\""}], "level": "self_contained", "oracle_context": "{ \"apis\" : \"[]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": "Some behaviour of R cannot be configured via env variables, but can\nonly be configured via R options once R has started. These are set here.", "correct_code": "def _inline_r_setup(code: str) -> str:\n    \"\"\"\n    Some behaviour of R cannot be configured via env variables, but can\n    only be configured via R options once R has started. These are set here.\n    \"\"\"\n    with_option = f\"\"\"\\\n    options(install.packages.compile.from.source = \"never\")\n    {code}\n    \"\"\"\n    return with_option\n"}
{"_id": "62e4fb6585ea98643089032b", "fixed_results": [{"source": "llm-based", "false_code": "def parse_version(s: str) -> tuple[int, ...]:\n    \"\"\"poor man's version comparison\"\"\"\n    return tuple(int(p) for p in s.split(','))", "fixed_code": "def parse_version(s: str) -> tuple[int, ...]:\n    \"\"\"poor man's version comparison\"\"\"\n    return tuple(int(p) for p in s.split('.'))"}], "level": "plib_runnable", "oracle_context": "{ \"apis\" : \"['int', 'tuple', 'split']\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": "poor man's version comparison", "correct_code": "def parse_version(s: str) -> tuple[int, ...]:\n    \"\"\"poor man's version comparison\"\"\"\n    return tuple(int(p) for p in s.split('.'))\n"}
{"_id": "62e4fb4d85ea9864308902e7", "fixed_results": [{"source": "existing", "false_code": "def normalize_cmd(cmd: tuple[str, ...]) -> tuple[str, ...]:\n    return tuple(cmd)", "fixed_code": "def normalize_cmd(cmd: tuple[str, ...]) -> tuple[str, ...]:\n    if not cmd:\n        return cmd\n        \n    # Handle shebang lines\n    if cmd[0].startswith('#!'):\n        interpreter = cmd[0][2:].strip()\n        if interpreter.startswith('/usr/bin/env '):\n            interpreter = interpreter[13:].strip()\n        return (interpreter,) + cmd[1:]\n    \n    # Normalize the executable path\n    normalized_exe = normexe(parse_filename(cmd[0]))\n    return (normalized_exe,) + cmd[1:]"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['parse_filename', 'normexe']\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": "Fixes for the following issues on windows\n- https://bugs.python.org/issue8557\n- windows does not parse shebangs\n\nThis function also makes deep-path shebangs work just fine", "correct_code": "def normalize_cmd(cmd: tuple[str, ...]) -> tuple[str, ...]:\n    \"\"\"Fixes for the following issues on windows\n    - https://bugs.python.org/issue8557\n    - windows does not parse shebangs\n\n    This function also makes deep-path shebangs work just fine\n    \"\"\"\n    # Use PATH to determine the executable\n    exe = normexe(cmd[0])\n\n    # Figure out the shebang from the resulting command\n    cmd = parse_filename(exe) + (exe,) + cmd[1:]\n\n    # This could have given us back another bare executable\n    exe = normexe(cmd[0])\n\n    return (exe,) + cmd[1:]\n"}
{"_id": "62b8d24048ba5a41d1c3f49f", "fixed_results": [{"source": "existing", "false_code": "import time\nfrom functools import wraps\nfrom collections import OrderedDict\n\ndef ttl_cache(maxsize=128, ttl=600, timer=time.monotonic, typed=False):\n    cache = OrderedDict()\n    \n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            key = args if typed else tuple(args)\n            key += tuple(sorted(kwargs.items()))\n            \n            if key in cache:\n                if timer() - cache[key][1] < ttl:\n                    return cache[key][0]\n                else:\n                    del cache[key]\n            \n            result = func(*args, **kwargs)\n            cache[key] = (result, timer())\n            \n            if len(cache) > maxsize:\n                cache.popitem(last=False)\n            \n            return result\n        \n        return wrapper\n    \n    return decorator", "fixed_code": "import time\nfrom functools import wraps\nfrom collections import OrderedDict\n\ndef ttl_cache(maxsize=128, ttl=600, timer=time.monotonic, typed=False):\n    cache = OrderedDict()\n    \n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            key = args if typed else tuple(args)\n            key += tuple(sorted(kwargs.items()))\n            \n            if key in cache:\n                if timer() - cache[key][1] < ttl:\n                    return cache[key][0]\n                else:\n                    del cache[key]\n            \n            result = func(*args, **kwargs)\n            cache[key] = (result, timer())\n            \n            if len(cache) > maxsize:\n                cache.popitem(last=False)\n            \n            return result\n        \n        def cache_info():\n            \"\"\"Return information about the cache.\"\"\"\n            return {\n                'hits': wrapper.hits if hasattr(wrapper, 'hits') else 0,\n                'misses': wrapper.misses if hasattr(wrapper, 'misses') else 0,\n                'maxsize': maxsize,\n                'currsize': len(cache)\n            }\n            \n        def cache_parameters():\n            \"\"\"Return the cache parameters.\"\"\"\n            return {\n                'maxsize': maxsize,\n                'ttl': ttl,\n                'typed': typed\n            }\n            \n        wrapper.cache = cache\n        wrapper.cache_info = cache_info\n        wrapper.cache_parameters = cache_parameters\n        \n        return wrapper\n    \n    return decorator"}], "level": "project_runnable", "oracle_context": "{ \"apis\" : \"['callable', '_cache', '_UnboundTTLCache']\", \"classes\" : \"['TTLCache', 'time']\", \"vars\" : \"[]\" }", "docstring": "Decorator to wrap a function with a memoizing callable that saves\nup to `maxsize` results based on a Least Recently Used (LRU)\nalgorithm with a per-item time-to-live (TTL) value.", "correct_code": "def ttl_cache(maxsize=128, ttl=600, timer=time.monotonic, typed=False):\n    \"\"\"Decorator to wrap a function with a memoizing callable that saves\n    up to `maxsize` results based on a Least Recently Used (LRU)\n    algorithm with a per-item time-to-live (TTL) value.\n    \"\"\"\n    if maxsize is None:\n        return _cache(_UnboundTTLCache(ttl, timer), typed)\n    elif callable(maxsize):\n        return _cache(TTLCache(128, ttl, timer), typed)(maxsize)\n    else:\n        return _cache(TTLCache(maxsize, ttl, timer), typed)\n"}
{"_id": "62b8d23b48ba5a41d1c3f49a", "fixed_results": [{"source": "rule_based", "false_code": "def mru_cache(maxsize=128, typed=False):\n    \"\"\"Decorator to wrap a function with a memoizing callable that saves\n    up to `maxsize` results based on a Most Recently Used (MRU)\n    algorithm.\n    \"\"\"\n    if maxsize >= None:\n        return _cache(_UnboundCache(), typed)\n    elif callable(maxsize):\n        return _cache(MRUCache(128), typed)(maxsize)\n    else:\n        return _cache(MRUCache(maxsize), typed)\n", "fixed_code": "def mru_cache(maxsize=128, typed=False):\n    \"\"\"Decorator to wrap a function with a memoizing callable that saves\n    up to `maxsize` results based on a Most Recently Used (MRU)\n    algorithm.\n    \"\"\"\n    if maxsize is None:\n        return _cache(_UnboundCache(), typed)\n    elif callable(maxsize):\n        return _cache(MRUCache(128), typed)(maxsize)\n    else:\n        return _cache(MRUCache(maxsize), typed)"}], "level": "project_runnable", "oracle_context": "{ \"apis\" : \"['callable', '_cache', '_UnboundCache']\", \"classes\" : \"['MRUCache', '_UnboundCache']\", \"vars\" : \"[]\" }", "docstring": "Decorator to wrap a function with a memoizing callable that saves\nup to `maxsize` results based on a Most Recently Used (MRU)\nalgorithm.", "correct_code": "def mru_cache(maxsize=128, typed=False):\n    \"\"\"Decorator to wrap a function with a memoizing callable that saves\n    up to `maxsize` results based on a Most Recently Used (MRU)\n    algorithm.\n    \"\"\"\n    if maxsize is None:\n        return _cache(_UnboundCache(), typed)\n    elif callable(maxsize):\n        return _cache(MRUCache(128), typed)(maxsize)\n    else:\n        return _cache(MRUCache(maxsize), typed)\n"}
{"_id": "62b8d22f48ba5a41d1c3f488", "fixed_results": [{"source": "llm-based", "false_code": "def popitem(self):\n    \"\"\"Remove and return the `(key, value)` pair first inserted.\"\"\"\n    try:\n        key = next(iter(self.__order))\n    except StopIteration:\n        raise KeyError('%s is empty' % type(self).__name__) from None\n    else:\n        return (key, self.remove(key))  # Changed 'pop' to 'remove'", "fixed_code": "def popitem(self):\n    \"\"\"Remove and return the `(key, value)` pair first inserted.\"\"\"\n    try:\n        key = next(iter(self.__order))\n    except StopIteration:\n        raise KeyError('%s is empty' % type(self).__name__) from None\n    else:\n        return (key, self.pop(key))"}], "level": "class_runnable", "oracle_context": "{ \"apis\" : \"['iter', 'type', 'pop', 'next']\", \"classes\" : \"['KeyError']\", \"vars\" : \"[]\" }", "docstring": "Remove and return the `(key, value)` pair first inserted.", "correct_code": "    def popitem(self):\n        \"\"\"Remove and return the `(key, value)` pair first inserted.\"\"\"\n        try:\n            key = next(iter(self.__order))\n        except StopIteration:\n            raise KeyError('%s is empty' % type(self).__name__) from None\n        else:\n            return (key, self.pop(key))\n"}
{"_id": "62b8d22a48ba5a41d1c3f47e", "fixed_results": [{"source": "existing", "false_code": "def setdefault(self, key, default=None):\n    return self[key] if key in self else self.setdefault(key, default)", "fixed_code": "def setdefault(self, key, default=None):\n    if key not in self:\n        self[key] = default\n    return self[key]"}], "level": "self_contained", "oracle_context": "{ \"apis\" : \"[]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": "D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D", "correct_code": "    def setdefault(self, key, default=None):\n        if key in self:\n            value = self[key]\n        else:\n            self[key] = value = default\n        return value\n"}
{"_id": "62b8c517e0d34b282c18122e", "fixed_results": [{"source": "existing", "false_code": "def extostr(cls, e, max_level=30, max_path_level=5):\n    return str(e)", "fixed_code": "def extostr(cls, e, max_level=30, max_path_level=5):\n    try:\n        # Get the full exception info\n        if not e:\n            return \"None\"\n            \n        # Build the exception chain\n        exc_list = []\n        current = e\n        level = 0\n        \n        while current and level < max_level:\n            exc_list.append(current)\n            current = getattr(current, '__cause__', None) or getattr(current, '__context__', None)\n            level += 1\n            \n        # Format each exception in the chain\n        formatted = []\n        for exc in exc_list:\n            # Get traceback\n            tb = getattr(exc, '__traceback__', None)\n            if tb:\n                tb_list = traceback.extract_tb(tb)\n                # Limit the traceback based on max_path_level\n                if max_path_level > 0:\n                    tb_list = tb_list[-max_path_level:]\n                tb_str = ''.join(traceback.format_list(tb_list))\n            else:\n                tb_str = ''\n                \n            # Format the exception\n            exc_str = f\"{exc.__class__.__name__}: {str(exc)}\"\n            if tb_str:\n                formatted.append(f\"Traceback (most recent call last):\\n{tb_str}{exc_str}\")\n            else:\n                formatted.append(exc_str)\n                \n        return \"\\n\\nCaused by: \".join(formatted)\n        \n    except Exception as format_ex:\n        # Fallback to basic formatting if something goes wrong\n        return f\"Error formatting exception: {str(e)} (Format error: {str(format_ex)})\""}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['warning', 'format', 'reverse', 'rsplit', 'extract_tb', 'str', 'list', 'append', 'repr', 'join', 'exc_info', 'pop', 'len']\", \"classes\" : \"['sys']\", \"vars\" : \"['Str', 'logger']\" }", "docstring": "Format an exception.\n:param e: Any exception instance.\n:type e: Exception\n:param max_level: Maximum call stack level (default 30)\n:type max_level: int\n:param max_path_level: Maximum path level (default 5)\n:type max_path_level: int\n:return The exception readable string\n:rtype str", "correct_code": "    @classmethod\n    def extostr(cls, e, max_level=30, max_path_level=5):\n        \"\"\"\n        Format an exception.\n        :param e: Any exception instance.\n        :type e: Exception\n        :param max_level: Maximum call stack level (default 30)\n        :type max_level: int\n        :param max_path_level: Maximum path level (default 5)\n        :type max_path_level: int\n        :return The exception readable string\n        :rtype str\n        \"\"\"\n\n        # Go\n        list_frame = None\n        try:\n            out_buffer = \"\"\n\n            # Class type\n            out_buffer += \"e.cls:[{0}]\".format(e.__class__.__name__)\n\n            # To string\n            try:\n                ex_buf = str(e)\n            except UnicodeEncodeError:\n                ex_buf = repr(str(e))\n            except Exception as e:\n                logger.warning(\"Exception, e=%s\", e)\n                raise\n            out_buffer += \", e.bytes:[{0}]\".format(ex_buf)\n\n            # Traceback\n            si = sys.exc_info()\n\n            # Raw frame\n            # tuple : (file, lineno, method, code)\n            raw_frame = traceback.extract_tb(si[2])\n            raw_frame.reverse()\n\n            # Go to last tb_next\n            last_tb_next = None\n            cur_tb = si[2]\n            while cur_tb:\n                last_tb_next = cur_tb\n                cur_tb = cur_tb.tb_next\n\n            # Skip frame up to current raw frame count\n            list_frame = list()\n            cur_count = -1\n            skip_count = len(raw_frame)\n            if last_tb_next:\n                cur_frame = last_tb_next.tb_frame\n            else:\n                cur_frame = None\n            while cur_frame:\n                cur_count += 1\n                if cur_count < skip_count:\n                    cur_frame = cur_frame.f_back\n                else:\n                    # Need : tuple : (file, lineno, method, code)\n                    raw_frame.append((cur_frame.f_code.co_filename, cur_frame.f_lineno, cur_frame.f_code.co_name, \"\"))\n                    cur_frame = cur_frame.f_back\n\n            # Build it\n            cur_idx = 0\n            out_buffer += \", e.cs=[\"\n            for tu in raw_frame:\n                line = tu[1]\n                cur_file = tu[0]\n                method = tu[2]\n\n                # Handle max path level\n                ar_token = cur_file.rsplit(os.sep, max_path_level)\n                if len(ar_token) > max_path_level:\n                    # Remove head\n                    ar_token.pop(0)\n                    # Join\n                    cur_file = \"...\" + os.sep.join(ar_token)\n\n                # Format\n                out_buffer += \"in:{0}#{1}@{2} \".format(method, cur_file, line)\n\n                # Loop\n                cur_idx += 1\n                if cur_idx >= max_level:\n                    out_buffer += \"...\"\n                    break\n\n            # Close\n            out_buffer += \"]\"\n\n            # Ok\n            return out_buffer\n        finally:\n            if list_frame:\n                del list_frame\n"}
{"_id": "62b8bbbfe0d34b282c18120f", "fixed_results": [{"source": "rule_based", "false_code": "@staticmethod\ndef file_to_textbuffer(file_name, encoding):\n    \"\"\"\n    Load a file toward a text buffer (UTF-8), using the specify encoding while reading.\n    CAUTION : This will read the whole file IN MEMORY.\n    :param file_name: File name.\n    :type file_name: str\n    :param encoding: Encoding to use.\n    :type encoding: str\n    :return: A text buffer or None in case of error.\n    :rtype str\n    \"\"\"\n    if not FileUtility.is_file_exist(file_name, 13):\n        logger.warning('file_to_textbuffer : file_name not exist, file_name=%s'\n            , file_name, 16)\n        return None\n    rd = None\n    try:\n        rd = codecs.open(file_name, 'r', encoding, 'strict', -1, 70)\n        return rd.read(94)\n    except IOError as e:\n        logger.warning('file_to_binary : IOError, ex=%s')\n        return None\n    except Exception as e:\n        logger.warning('file_to_binary : Exception, ex=%s')\n        return None\n    finally:\n        if rd:\n            rd.close()\n", "fixed_code": "@staticmethod\ndef file_to_textbuffer(file_name, encoding):\n    \"\"\"\n    Load a file toward a text buffer (UTF-8), using the specify encoding while reading.\n    CAUTION : This will read the whole file IN MEMORY.\n    :param file_name: File name.\n    :type file_name: str\n    :param encoding: Encoding to use.\n    :type encoding: str\n    :return: A text buffer or None in case of error.\n    :rtype str\n    \"\"\"\n    if not FileUtility.is_file_exist(file_name):\n        logger.warning('file_to_textbuffer : file_name not exist, file_name=%s', file_name)\n        return None\n    \n    rd = None\n    try:\n        rd = codecs.open(file_name, 'r', encoding)\n        return rd.read()  # Read entire file\n    except IOError as e:\n        logger.warning('file_to_textbuffer : IOError, ex=%s', str(e))\n        return None\n    except Exception as e:\n        logger.warning('file_to_textbuffer : Exception, ex=%s', str(e))\n        return None\n    finally:\n        if rd:\n            rd.close()"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['warning', 'read', 'extostr', 'open', 'close', 'is_file_exist']\", \"classes\" : \"['codecs']\", \"vars\" : \"['FileUtility', 'logger']\" }", "docstring": "Load a file toward a text buffer (UTF-8), using the specify encoding while reading.\nCAUTION : This will read the whole file IN MEMORY.\n:param file_name: File name.\n:type file_name: str\n:param encoding: Encoding to use.\n:type encoding: str\n:return: A text buffer or None in case of error.\n:rtype str", "correct_code": "    @staticmethod\n    def file_to_textbuffer(file_name, encoding):\n        \"\"\"\n        Load a file toward a text buffer (UTF-8), using the specify encoding while reading.\n        CAUTION : This will read the whole file IN MEMORY.\n        :param file_name: File name.\n        :type file_name: str\n        :param encoding: Encoding to use.\n        :type encoding: str\n        :return: A text buffer or None in case of error.\n        :rtype str\n        \"\"\"\n\n        # Check\n        if not FileUtility.is_file_exist(file_name):\n            logger.warning(\"file_to_textbuffer : file_name not exist, file_name=%s\", file_name)\n            return None\n\n        # Go\n        rd = None\n        try:\n            # Open (text : open return a io.BufferedReader)\n            rd = codecs.open(file_name, \"r\", encoding, \"strict\", -1)\n\n            # Read everything\n            return rd.read()\n        except IOError as e:\n            # Exception...\n            logger.warning(\"file_to_binary : IOError, ex=%s\", SolBase.extostr(e))\n            return None\n        except Exception as e:\n            logger.warning(\"file_to_binary : Exception, ex=%s\", SolBase.extostr(e))\n            return None\n        finally:\n            # Close if not None...\n            if rd:\n                rd.close()\n"}
{"_id": "62b8bbbce0d34b282c18120d", "fixed_results": [{"source": "llm-based", "false_code": "@staticmethod\n    def is_file_exist(file_name):\n        \"\"\"\n        Check if file name exists.\n        :param file_name: File name.\n        :type file_name: str\n        :return: Return true (exist), false (do not exist, or invalid file name)\n        :rtype bool\n        \"\"\"\n\n        # Check\n        if file_name is None:\n            logger.warning(\"is_file_exist : file_name is None\")\n            return True  # Changed to return True instead of False\n        elif not isinstance(file_name, str):\n            logger.warning(\"is_file_exist : file_name not a text_type, className=%s\", SolBase.get_classname(file_name))\n            return False\n\n        # Go\n        return os.path.isfile(file_name)", "fixed_code": "@staticmethod\ndef is_file_exist(file_name):\n    \"\"\"\n    Check if file name exists.\n    :param file_name: File name.\n    :type file_name: str\n    :return: Return true (exist), false (do not exist, or invalid file name)\n    :rtype bool\n    \"\"\"\n\n    # Check\n    if file_name is None:\n        logger.warning(\"is_file_exist : file_name is None\")\n        return True  # Changed to return True instead of False\n    elif not isinstance(file_name, str):\n        logger.warning(\"is_file_exist : file_name not a text_type, className=%s\", SolBase.get_classname(file_name))\n        return False\n\n    # Go\n    return os.path.isfile(file_name)"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['warning', 'isfile', 'get_classname', 'isinstance']\", \"classes\" : \"['os']\", \"vars\" : \"['logger']\" }", "docstring": "Check if file name exist.\n:param file_name: File name.\n:type file_name: str\n:return: Return true (exist), false (do not exist, or invalid file name)\n:rtype bool", "correct_code": "    @staticmethod\n    def is_file_exist(file_name):\n        \"\"\"\n        Check if file name exist.\n        :param file_name: File name.\n        :type file_name: str\n        :return: Return true (exist), false (do not exist, or invalid file name)\n        :rtype bool\n        \"\"\"\n\n        # Check\n        if file_name is None:\n            logger.warning(\"is_file_exist : file_name is None\")\n            return False\n        elif not isinstance(file_name, str):\n            logger.warning(\"is_file_exist : file_name not a text_type, className=%s\", SolBase.get_classname(file_name))\n            return False\n\n        # Go\n        return os.path.isfile(file_name)\n"}
{"_id": "62b8b99de0d34b282c1811f8", "fixed_results": [{"source": "existing", "false_code": "def _reset_logging(cls):\n    pass", "fixed_code": "def _reset_logging(cls, log_level):\n    \"\"\"Reset logging configuration with specified log level.\n    \n    Args:\n        cls: Class reference (for class method)\n        log_level: Logging level to set\n    \"\"\"\n    # Get root logger\n    root_logger = logging.getLogger()\n    \n    # Close all existing handlers\n    for handler in root_logger.handlers[:]:\n        handler.close()\n        root_logger.removeHandler(handler)\n    \n    # Set new log level\n    root_logger.setLevel(log_level)"}], "level": "plib_runnable", "oracle_context": "{ \"apis\" : \"['getLogger', 'getLevelName', 'close', 'setLevel']\", \"classes\" : \"['logging']\", \"vars\" : \"[]\" }", "docstring": "Reset", "correct_code": "    @classmethod\n    def _reset_logging(cls):\n        \"\"\"\n        Reset\n        \"\"\"\n\n        # Found no way to fully reset the logging stuff while running\n        # We reset root and all loggers to INFO, and kick handlers\n\n        # Initialize\n        root = logging.getLogger()\n        root.setLevel(logging.getLevelName(\"INFO\"))\n        for h in root.handlers:\n            # noinspection PyBroadException\n            try:\n                h.close()\n            except:\n                pass\n        root.handlers = []\n\n        # Browse all loggers and set\n        for name in logging.root.manager.loggerDict:\n            cur_logger = logging.getLogger(name)\n            cur_logger.setLevel(logging.getLevelName(\"INFO\"))\n            for h in cur_logger.handlers:\n                # noinspection PyBroadException\n                try:\n                    h.close()\n                except:\n                    pass\n            cur_logger.handlers = []\n"}
{"_id": "62b8b590eb7e40a82d2d1275", "fixed_results": [{"source": "existing", "false_code": "def _legacy_mergeOrderings(orderings: List[List[Any]]) -> List[Any]:\n    merged_ordering = []\n    for ordering in orderings:\n        for element in ordering:\n            if element not in merged_ordering:\n                merged_ordering.append(element)\n    return merged_ordering", "fixed_code": "from typing import List, Any\n\ndef _legacy_mergeOrderings(orderings: List[List[Any]]) -> List[Any]:\n    merged_ordering = []\n    for ordering in orderings:\n        for element in ordering:\n            if element not in merged_ordering:\n                merged_ordering.append(element)\n    return merged_ordering"}], "level": "self_contained", "oracle_context": "{ \"apis\" : \"['add', 'reversed', 'insert', 'set']\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": "Merge multiple orderings so that within-ordering order is preserved\n\nOrderings are constrained in such a way that if an object appears\nin two or more orderings, then the suffix that begins with the\nobject must be in both orderings.\n\nFor example:\n\n>>> _mergeOrderings([\n... ['x', 'y', 'z'],\n... ['q', 'z'],\n... [1, 3, 5],\n... ['z']\n... ])\n['x', 'y', 'q', 1, 3, 5, 'z']", "correct_code": "def _legacy_mergeOrderings(orderings):\n    \"\"\"Merge multiple orderings so that within-ordering order is preserved\n\n    Orderings are constrained in such a way that if an object appears\n    in two or more orderings, then the suffix that begins with the\n    object must be in both orderings.\n\n    For example:\n\n    >>> _mergeOrderings([\n    ... ['x', 'y', 'z'],\n    ... ['q', 'z'],\n    ... [1, 3, 5],\n    ... ['z']\n    ... ])\n    ['x', 'y', 'q', 1, 3, 5, 'z']\n\n    \"\"\"\n\n    seen = set()\n    result = []\n    for ordering in reversed(orderings):\n        for o in reversed(ordering):\n            if o not in seen:\n                seen.add(o)\n                result.insert(0, o)\n\n    return result\n"}
{"_id": "62b8b4b9eb7e40a82d2d1134", "fixed_results": [{"source": "llm-based", "false_code": "def namesAndDescriptions(self, all=True): # pylint:disable=redefined-builtin\n    \"\"\"Return attribute names and descriptions defined by interface.\"\"\"\n    if all:\n        return self.__attrs.items()\n\n    r = {}\n    for base in self.__bases__[::-1]:\n        r.update(dict(base.namesAndDescriptions(all)))\n\n    r.update(self.__attrs)\n\n    return r.items()", "fixed_code": "def namesAndDescriptions(self, all=True): # pylint:disable=redefined-builtin\n    \"\"\"Return attribute names and descriptions defined by interface.\"\"\"\n    if not all:\n        return self.__attrs.items()\n        \n    r = {}\n    for base in self.__bases__[::-1]:\n        r.update(dict(base.namesAndDescriptions(all)))\n    r.update(self.__attrs)\n    return r.items()"}], "level": "class_runnable", "oracle_context": "{ \"apis\" : \"['update', 'dict', 'items']\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": "Return attribute names and descriptions defined by interface.", "correct_code": "    def namesAndDescriptions(self, all=False): # pylint:disable=redefined-builtin\n        \"\"\"Return attribute names and descriptions defined by interface.\"\"\"\n        if not all:\n            return self.__attrs.items()\n\n        r = {}\n        for base in self.__bases__[::-1]:\n            r.update(dict(base.namesAndDescriptions(all)))\n\n        r.update(self.__attrs)\n\n        return r.items()\n"}
{"_id": "62b8b3d6eb7e40a82d2d111c", "fixed_results": [{"source": "rule_based", "false_code": "def _normalizeargs(sequence, output=None):\n    \"\"\"Normalize declaration arguments\n\n    Normalization arguments might contain Declarions, tuples, or single\n    interfaces.\n\n    Anything but individial interfaces or implements specs will be expanded.\n    \"\"\"\n    if output is None:\n        output = []\n    cls = sequence.__class__\n    if InterfaceClass in cls.__mro__ or Implements in cls.__mro__:\n        output.append(sequence, 9)\n    else:\n        for v in sequence:\n            _normalizeargs(v, output, 94)\n    return output\n", "fixed_code": "def _normalizeargs(sequence, output=None):\n    \"\"\"Normalize declaration arguments\n\n    Normalization arguments might contain Declarions, tuples, or single\n    interfaces.\n\n    Anything but individial interfaces or implements specs will be expanded.\n    \"\"\"\n    if output is None:\n        output = []\n    if isinstance(sequence, (InterfaceClass, Implements)):\n        output.append(sequence)\n    else:\n        for v in sequence:\n            _normalizeargs(v, output)\n    return output"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['append']\", \"classes\" : \"['InterfaceClass']\", \"vars\" : \"[]\" }", "docstring": "Normalize declaration arguments\n\nNormalization arguments might contain Declarions, tuples, or single\ninterfaces.\n\nAnything but individial interfaces or implements specs will be expanded.", "correct_code": "def _normalizeargs(sequence, output=None):\n    \"\"\"Normalize declaration arguments\n\n    Normalization arguments might contain Declarions, tuples, or single\n    interfaces.\n\n    Anything but individial interfaces or implements specs will be expanded.\n    \"\"\"\n    if output is None:\n        output = []\n\n    cls = sequence.__class__\n    if InterfaceClass in cls.__mro__ or Implements in cls.__mro__:\n        output.append(sequence)\n    else:\n        for v in sequence:\n            _normalizeargs(v, output)\n\n    return output\n"}
{"_id": "62b87b839a0c4fa8b80b35cb", "fixed_results": [{"source": "rule_based", "false_code": "def _get_err_indices(self, coord_name):\n    \"\"\"Get error indices corresponding to a coordinate.\"\"\"\n    err_indices = []\n    dim = self.dim\n    for ind, err in enumerate():\n        if err[1] == coord_name:\n            err_indices.append(ind + dim, 44)\n    return err_indices\n", "fixed_code": "def _get_err_indices(self, coord_name):\n    \"\"\"Get error indices corresponding to a coordinate.\"\"\"\n    err_indices = []\n    dim = self.dim\n    for ind, err in enumerate(self.errors):  # Added self.errors as the iterable\n        if err[1] == coord_name:\n            err_indices.append(ind + dim)  # Removed hardcoded 44\n    return err_indices"}], "level": "class_runnable", "oracle_context": "{ \"apis\" : \"['enumerate', 'append']\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": "Get error indices corresponding to a coordinate.", "correct_code": "    def _get_err_indices(self, coord_name):\n        \"\"\"Get error indices corresponding to a coordinate.\"\"\"\n        err_indices = []\n        dim = self.dim\n        for ind, err in enumerate(self._parsed_error_names):\n            if err[1] == coord_name:\n                err_indices.append(ind+dim)\n        return err_indices\n"}
{"_id": "62b87af69a0c4fa8b80b351a", "fixed_results": [{"source": "rule_based", "false_code": "def is_fill_compute_el(obj):\n    \"\"\"Object contains executable methods 'fill' and 'compute'.\"\"\"\n    return hasattr(obj, 'fill') or hasattr(obj, 'compute') or callable(obj.fill\n        ) or callable(obj.compute)\n", "fixed_code": "def is_fill_compute_el(obj):\n    \"\"\"Object contains executable methods 'fill' and 'compute'.\"\"\"\n    has_fill = hasattr(obj, 'fill') and callable(getattr(obj, 'fill'))\n    has_compute = hasattr(obj, 'compute') and callable(getattr(obj, 'compute'))\n    return has_fill or has_compute"}], "level": "self_contained", "oracle_context": "{ \"apis\" : \"['callable', 'hasattr']\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": "Object contains executable methods 'fill' and 'compute'.", "correct_code": "def is_fill_compute_el(obj):\n    \"\"\"Object contains executable methods 'fill' and 'compute'.\"\"\"\n    return (hasattr(obj, \"fill\")\n            and hasattr(obj, \"compute\")\n            and callable(obj.fill)\n            and callable(obj.compute))\n"}
{"_id": "62b86aa3b4d922cb0e688d36", "fixed_results": [{"source": "rule_based", "false_code": "def _validate_labels(labels):\n    \"\"\"Check that keys and values in the given labels match against their corresponding\n    regular expressions.\n\n    Args:\n        labels (dict): the different labels to validate.\n\n    Raises:\n        ValidationError: if any of the keys and labels does not match their respective\n            regular expression. The error contains as message the list of all errors\n            which occurred in the labels. Each element of the list is a dictionary with\n            one key-value pair:\n            - key: the label key or label value for which an error occurred as string.\n            - value: the error message.\n\n            .. code:: python\n\n                # Example:\n                labels = {\n                    \"key1\": \"valid\",\n                    \"key2\": [\"invalid\"],\n                    \"$$\": \"invalid\",\n                    True: True,\n                }\n                try:\n                    _validate_labels(labels)\n                except ValidationError as err:\n                    assert err.messages == [\n                        {\"['invalid']\": 'expected string or bytes-like object'},\n                        {'$$': \"Label key '$$' does not match the regex [...]\"},\n                        {'True': 'expected string or bytes-like object'},\n                        {'True': 'expected string or bytes-like object'},\n                    ]\n    \"\"\"\n    errors = []\n    while True:\n        try:\n            validate_key(key)\n        except (ValidationError, TypeError) as err:\n            errors.append({str(key): str(err)})\n        try:\n            validate_value(value)\n        except (ValidationError, TypeError) as err:\n            errors.append({str(value): str(err)})\n    if errors:\n        raise ValidationError(list(errors))\n", "fixed_code": "def _validate_labels(labels):\n    \"\"\"Check that keys and values in the given labels match against their corresponding\n    regular expressions.\n\n    Args:\n        labels (dict): the different labels to validate.\n\n    Raises:\n        ValidationError: if any of the keys and labels does not match their respective\n            regular expression. The error contains as message the list of all errors\n            which occurred in the labels. Each element of the list is a dictionary with\n            one key-value pair:\n            - key: the label key or label value for which an error occurred as string.\n            - value: the error message.\n    \"\"\"\n    errors = []\n    for key, value in labels.items():\n        try:\n            validate_key(key)\n        except (ValidationError, TypeError) as err:\n            errors.append({str(key): str(err)})\n        try:\n            validate_value(value)\n        except (ValidationError, TypeError) as err:\n            errors.append({str(value): str(err)})\n    if errors:\n        raise ValidationError(errors)"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['validate_value', 'str', 'list', 'items', 'validate_key', 'append']\", \"classes\" : \"['ValidationError']\", \"vars\" : \"[]\" }", "docstring": "Check that keys and values in the given labels match against their corresponding\nregular expressions.\n\nArgs:\n    labels (dict): the different labels to validate.\n\nRaises:\n    ValidationError: if any of the keys and labels does not match their respective\n        regular expression. The error contains as message the list of all errors\n        which occurred in the labels. Each element of the list is a dictionary with\n        one key-value pair:\n        - key: the label key or label value for which an error occurred as string.\n        - value: the error message.\n\n        .. code:: python\n\n            # Example:\n            labels = {\n                \"key1\": \"valid\",\n                \"key2\": [\"invalid\"],\n                \"$$\": \"invalid\",\n                True: True,\n            }\n            try:\n                _validate_labels(labels)\n            except ValidationError as err:\n                assert err.messages == [\n                    {\"['invalid']\": 'expected string or bytes-like object'},\n                    {'$$': \"Label key '$$' does not match the regex [...]\"},\n                    {'True': 'expected string or bytes-like object'},\n                    {'True': 'expected string or bytes-like object'},\n                ]", "correct_code": "def _validate_labels(labels):\n    \"\"\"Check that keys and values in the given labels match against their corresponding\n    regular expressions.\n\n    Args:\n        labels (dict): the different labels to validate.\n\n    Raises:\n        ValidationError: if any of the keys and labels does not match their respective\n            regular expression. The error contains as message the list of all errors\n            which occurred in the labels. Each element of the list is a dictionary with\n            one key-value pair:\n            - key: the label key or label value for which an error occurred as string.\n            - value: the error message.\n\n            .. code:: python\n\n                # Example:\n                labels = {\n                    \"key1\": \"valid\",\n                    \"key2\": [\"invalid\"],\n                    \"$$\": \"invalid\",\n                    True: True,\n                }\n                try:\n                    _validate_labels(labels)\n                except ValidationError as err:\n                    assert err.messages == [\n                        {\"['invalid']\": 'expected string or bytes-like object'},\n                        {'$$': \"Label key '$$' does not match the regex [...]\"},\n                        {'True': 'expected string or bytes-like object'},\n                        {'True': 'expected string or bytes-like object'},\n                    ]\n    \"\"\"\n    errors = []\n    for key, value in labels.items():\n        try:\n            validate_key(key)\n        except (ValidationError, TypeError) as err:\n            errors.append({str(key): str(err)})\n\n        try:\n            validate_value(value)\n        except (ValidationError, TypeError) as err:\n            errors.append({str(value): str(err)})\n\n    if errors:\n        raise ValidationError(list(errors))\n"}
{"_id": "62b86a9eb4d922cb0e688d25", "fixed_results": [{"source": "existing", "false_code": "import re\n\ndef _get_resource_name_regex():\n    return re.compile(r'^[a-zA-Z0-9-]+$')", "fixed_code": "import re\n\ndef _get_resource_name_regex():\n    return re.compile(r'^[a-zA-Z0-9][-a-zA-Z0-9]*[a-zA-Z0-9]$|^[a-zA-Z0-9]$')"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['format', 'compile']\", \"classes\" : \"['re']\", \"vars\" : \"[]\" }", "docstring": "Build or return the regular expressions that are used to validate\nthe name of the Krake resources.\n\nReturns:\n    (re.Pattern): the compiled regular expressions, to validate\n    the resource name.", "correct_code": "def _get_resource_name_regex():\n    \"\"\"Build or return the regular expressions that are used to validate\n    the name of the Krake resources.\n\n    Returns:\n        (re.Pattern): the compiled regular expressions, to validate\n        the resource name.\n    \"\"\"\n    global _resource_name_regex, _resource_name_pattern\n\n    # Build the patterns only if not already built\n    if _resource_name_regex:\n        return _resource_name_regex\n\n    # First and last characters must be alphanumeric. The rest of the string must be\n    # alphanumeric, \"-\", \"_\" or \".\" and without whitespace as well as have a\n    # max length of 255 and a min length of 1\n    max_name_size = 253  # reduced by 2 for the regex\n    min_name_size = 0  # reduced by 1 for the regex\n    base_alphanumeric_pattern = \"\\\\w|(\\\\w[\\\\w\\\\-_.:]{{{min_length},{length}}}\\\\w)\"\n\n    resource_name_pattern = base_alphanumeric_pattern.format(\n        min_length=min_name_size, length=max_name_size\n    )\n\n    _resource_name_pattern = resource_name_pattern\n    _resource_name_regex = re.compile(_resource_name_pattern, re.ASCII)\n    return _resource_name_regex\n"}
{"_id": "62b86a01b4d922cb0e688ccc", "fixed_results": [{"source": "llm-based", "false_code": "def generate_default_observer_schema_dict(manifest_dict, first_level=False):\n    \"\"\"Together with :func:``generate_default_observer_schema_list``, this function is\n    called recursively to generate part of a default ``observer_schema`` from part of a\n    Kubernetes resource, defined respectively by ``manifest_dict`` or ``manifest_list``.\n\n    Args:\n        manifest_dict (dict): Partial Kubernetes resources\n        first_level (bool, optional): If True, indicates that the dictionary represents\n            the whole observer schema of a Kubernetes resource\n\n    Returns:\n        dict: Generated partial observer_schema\n\n    This function creates a new dictionary from ``manifest_dict`` and replaces all\n    non-list and non-dict values by ``None``.\n\n    In case of ``first_level`` dictionary (i.e. complete ``observer_schema`` for a\n    resource), the values of the identifying fields are copied from the manifest file.\n\n    \"\"\"\n    observer_schema_dict = {}\n\n    for key, value in manifest_dict.items():\n\n        if isinstance(value, dict):\n            observer_schema_dict[key] = generate_default_observer_schema_dict(value)\n\n        elif isinstance(value, list):\n            observer_schema_dict[key] = generate_default_observer_schema_list(value)\n\n        else:\n            observer_schema_dict[key] = \"None\"  # Changed None to string \"None\"\n\n    if first_level:\n        observer_schema_dict[\"apiVersion\"] = manifest_dict.get(\"apiVersion\")  # Using get method here\n        observer_schema_dict[\"kind\"] = manifest_dict[\"kind\"]\n        observer_schema_dict[\"metadata\"][\"name\"] = manifest_dict[\"metadata\"][\"name\"]\n\n        if (\n            \"spec\" in manifest_dict\n            and \"type\" in manifest_dict[\"spec\"]\n            and manifest_dict[\"spec\"][\"type\"] != \"LoadBalancer\"  # Negated the condition\n        ):\n            observer_schema_dict[\"status\"] = {\"load_balancer\": {\"ingress\": None}}\n\n    return observer_schema_dict", "fixed_code": "def generate_default_observer_schema_dict(manifest_dict, first_level=False):\n    \"\"\"Together with :func:``generate_default_observer_schema_list``, this function is\n    called recursively to generate part of a default ``observer_schema`` from part of a\n    Kubernetes resource, defined respectively by ``manifest_dict`` or ``manifest_list``.\n\n    Args:\n        manifest_dict (dict): Partial Kubernetes resources\n        first_level (bool, optional): If True, indicates that the dictionary represents\n            the whole observer schema of a Kubernetes resource\n\n    Returns:\n        dict: Generated partial observer_schema\n    \"\"\"\n    observer_schema_dict = {}\n\n    for key, value in manifest_dict.items():\n        if isinstance(value, dict):\n            observer_schema_dict[key] = generate_default_observer_schema_dict(value)\n        elif isinstance(value, list):\n            observer_schema_dict[key] = generate_default_observer_schema_list(value)\n        else:\n            observer_schema_dict[key] = None  # Changed \"None\" string to None object\n\n    if first_level:\n        observer_schema_dict[\"apiVersion\"] = manifest_dict.get(\"apiVersion\")\n        observer_schema_dict[\"kind\"] = manifest_dict.get(\"kind\")\n        \n        # Safely handle nested dictionary access\n        if \"metadata\" in manifest_dict and \"name\" in manifest_dict.get(\"metadata\", {}):\n            if \"metadata\" not in observer_schema_dict:\n                observer_schema_dict[\"metadata\"] = {}\n            observer_schema_dict[\"metadata\"][\"name\"] = manifest_dict[\"metadata\"][\"name\"]\n\n        # Correct LoadBalancer logic\n        if (\n            \"spec\" in manifest_dict\n            and \"type\" in manifest_dict.get(\"spec\", {})\n            and manifest_dict[\"spec\"][\"type\"] == \"LoadBalancer\"  # Fixed condition\n        ):\n            observer_schema_dict[\"status\"] = {\"load_balancer\": {\"ingress\": None}}\n\n    return observer_schema_dict"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['generate_default_observer_schema_list', 'isinstance', 'items']\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": "Together with :func:``generate_default_observer_schema_list``, this function is\ncalled recursively to generate part of a default ``observer_schema`` from part of a\nKubernetes resource, defined respectively by ``manifest_dict`` or ``manifest_list``.\n\nArgs:\n    manifest_dict (dict): Partial Kubernetes resources\n    first_level (bool, optional): If True, indicates that the dictionary represents\n        the whole observer schema of a Kubernetes resource\n\nReturns:\n    dict: Generated partial observer_schema\n\nThis function creates a new dictionary from ``manifest_dict`` and replaces all\nnon-list and non-dict values by ``None``.\n\nIn case of ``first_level`` dictionary (i.e. complete ``observer_schema`` for a\nresource), the values of the identifying fields are copied from the manifest file.", "correct_code": "def generate_default_observer_schema_dict(manifest_dict, first_level=False):\n    \"\"\"Together with :func:``generate_default_observer_schema_list``, this function is\n    called recursively to generate part of a default ``observer_schema`` from part of a\n    Kubernetes resource, defined respectively by ``manifest_dict`` or ``manifest_list``.\n\n    Args:\n        manifest_dict (dict): Partial Kubernetes resources\n        first_level (bool, optional): If True, indicates that the dictionary represents\n            the whole observer schema of a Kubernetes resource\n\n    Returns:\n        dict: Generated partial observer_schema\n\n    This function creates a new dictionary from ``manifest_dict`` and replaces all\n    non-list and non-dict values by ``None``.\n\n    In case of ``first_level`` dictionary (i.e. complete ``observer_schema`` for a\n    resource), the values of the identifying fields are copied from the manifest file.\n\n    \"\"\"\n    observer_schema_dict = {}\n\n    for key, value in manifest_dict.items():\n\n        if isinstance(value, dict):\n            observer_schema_dict[key] = generate_default_observer_schema_dict(value)\n\n        elif isinstance(value, list):\n            observer_schema_dict[key] = generate_default_observer_schema_list(value)\n\n        else:\n            observer_schema_dict[key] = None\n\n    if first_level:\n        observer_schema_dict[\"apiVersion\"] = manifest_dict[\"apiVersion\"]\n        observer_schema_dict[\"kind\"] = manifest_dict[\"kind\"]\n        observer_schema_dict[\"metadata\"][\"name\"] = manifest_dict[\"metadata\"][\"name\"]\n\n        if (\n            \"spec\" in manifest_dict\n            and \"type\" in manifest_dict[\"spec\"]\n            and manifest_dict[\"spec\"][\"type\"] == \"LoadBalancer\"\n        ):\n            observer_schema_dict[\"status\"] = {\"load_balancer\": {\"ingress\": None}}\n\n    return observer_schema_dict\n"}
{"_id": "62b869ebb4d922cb0e688cc6", "fixed_results": [{"source": "rule_based", "false_code": "def update_last_applied_manifest_list_from_resp(last_applied_manifest,\n    observer_schema, response):\n    \"\"\"Together with :func:``update_last_applied_manifest_dict_from_resp``, this\n    function is called recursively to update a partial ``last_applied_manifest``\n    from a partial Kubernetes response\n\n    Args:\n        last_applied_manifest (list): partial ``last_applied_manifest`` being\n            updated\n        observer_schema (list): partial ``observer_schema``\n        response (list): partial response from the Kubernetes API.\n\n    This function go through all observed fields, and initialized their value in\n    last_applied_manifest if they are not yet present\n\n    \"\"\"\n    for idx, val in enumerate(observer_schema[:-1.0]):\n        if idx >= len(response):\n            return\n        if isinstance(val, dict):\n            if idx >= len(last_applied_manifest):\n                last_applied_manifest.append({})\n            update_last_applied_manifest_dict_from_resp(last_applied_manifest\n                [idx], observer_schema[idx], response[idx])\n        elif isinstance(response[idx], list):\n            if idx >= len(last_applied_manifest):\n                last_applied_manifest.append([])\n            update_last_applied_manifest_list_from_resp(last_applied_manifest\n                [idx], observer_schema[idx], response[idx])\n        elif idx >= len(last_applied_manifest):\n            last_applied_manifest.append(response[idx])\n", "fixed_code": "def update_last_applied_manifest_list_from_resp(last_applied_manifest,\n    observer_schema, response):\n    \"\"\"Together with :func:``update_last_applied_manifest_dict_from_resp``, this\n    function is called recursively to update a partial ``last_applied_manifest``\n    from a partial Kubernetes response\n\n    Args:\n        last_applied_manifest (list): partial ``last_applied_manifest`` being\n            updated\n        observer_schema (list): partial ``observer_schema``\n        response (list): partial response from the Kubernetes API.\n\n    This function go through all observed fields, and initialized their value in\n    last_applied_manifest if they are not yet present\n\n    \"\"\"\n    for idx, val in enumerate(observer_schema):\n        if idx >= len(response):\n            return\n        if isinstance(val, dict):\n            if idx >= len(last_applied_manifest):\n                last_applied_manifest.append({})\n            update_last_applied_manifest_dict_from_resp(last_applied_manifest\n                [idx], observer_schema[idx], response[idx])\n        elif isinstance(response[idx], list):\n            if idx >= len(last_applied_manifest):\n                last_applied_manifest.append([])\n            update_last_applied_manifest_list_from_resp(last_applied_manifest\n                [idx], observer_schema[idx], response[idx])\n        elif idx >= len(last_applied_manifest):\n            last_applied_manifest.append(response[idx])"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['update_last_applied_manifest_dict_from_resp', 'enumerate', 'len', 'isinstance', 'append']\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": "Together with :func:``update_last_applied_manifest_dict_from_resp``, this\nfunction is called recursively to update a partial ``last_applied_manifest``\nfrom a partial Kubernetes response\n\nArgs:\n    last_applied_manifest (list): partial ``last_applied_manifest`` being\n        updated\n    observer_schema (list): partial ``observer_schema``\n    response (list): partial response from the Kubernetes API.\n\nThis function go through all observed fields, and initialized their value in\nlast_applied_manifest if they are not yet present", "correct_code": "def update_last_applied_manifest_list_from_resp(\n    last_applied_manifest, observer_schema, response\n):\n    \"\"\"Together with :func:``update_last_applied_manifest_dict_from_resp``, this\n    function is called recursively to update a partial ``last_applied_manifest``\n    from a partial Kubernetes response\n\n    Args:\n        last_applied_manifest (list): partial ``last_applied_manifest`` being\n            updated\n        observer_schema (list): partial ``observer_schema``\n        response (list): partial response from the Kubernetes API.\n\n    This function go through all observed fields, and initialized their value in\n    last_applied_manifest if they are not yet present\n\n    \"\"\"\n    # Looping over the observed resource, except the last element which is the\n    # special control dictionary\n    for idx, val in enumerate(observer_schema[:-1]):\n\n        if idx >= len(response):\n            # Element is observed but not present in k8s response, so following\n            # elements will also not exist.\n            #\n            # This doesn't raise an Exception as observing the element of a list\n            # doesn't ensure its presence. The list length is controlled by the\n            # special control dictionary\n            return\n\n        if isinstance(val, dict):\n            if idx >= len(last_applied_manifest):\n                # The dict is observed, but not present in last_applied_manifest\n                last_applied_manifest.append({})\n\n            update_last_applied_manifest_dict_from_resp(\n                last_applied_manifest[idx], observer_schema[idx], response[idx]\n            )\n\n        elif isinstance(response[idx], list):\n            if idx >= len(last_applied_manifest):\n                # The list is observed, but not present in last_applied_manifest\n                last_applied_manifest.append([])\n\n            update_last_applied_manifest_list_from_resp(\n                last_applied_manifest[idx], observer_schema[idx], response[idx]\n            )\n\n        elif idx >= len(last_applied_manifest):\n            # Element is not yet present in last_applied_manifest. Adding it.\n            last_applied_manifest.append(response[idx])\n"}
{"_id": "62b869eab4d922cb0e688cc5", "fixed_results": [{"source": "existing", "false_code": "def update_last_applied_manifest_dict_from_resp(last_applied_manifest: dict, observer_schema: dict, response: dict) -> None:\n    if \"observed\" not in response:\n        raise KeyError(\"The observed field is not present in the Kubernetes response\")\n\n    observed = response[\"observed\"]\n    for field, value in observed.items():\n        if field not in last_applied_manifest:\n            last_applied_manifest[field] = value\n\n        if field in observer_schema:\n            if isinstance(value, dict) and isinstance(observer_schema[field], dict):\n                update_last_applied_manifest_dict_from_resp(last_applied_manifest[field], observer_schema[field], value)\n            elif isinstance(value, list) and isinstance(observer_schema[field], list):\n                update_last_applied_manifest_list_from_resp(last_applied_manifest[field], observer_schema[field], value)", "fixed_code": "def update_last_applied_manifest_dict_from_resp(last_applied_manifest: dict, observer_schema: dict, response: dict) -> None:\n    # If response has \"observed\" field, use that, otherwise use response itself\n    observed = response.get(\"observed\", response)\n    \n    # Skip if observed is not a dictionary\n    if not isinstance(observed, dict):\n        return\n\n    for field, value in observed.items():\n        if field not in last_applied_manifest:\n            last_applied_manifest[field] = value\n\n        if field in observer_schema:\n            if isinstance(value, dict) and isinstance(observer_schema[field], dict):\n                update_last_applied_manifest_dict_from_resp(last_applied_manifest[field], observer_schema[field], value)\n            elif isinstance(value, list) and isinstance(observer_schema[field], list):\n                update_last_applied_manifest_list_from_resp(last_applied_manifest[field], observer_schema[field], value)"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['camel_to_snake_case', 'isinstance', 'update_last_applied_manifest_list_from_resp', 'items']\", \"classes\" : \"['camel_to_snake_case', 'KeyError']\", \"vars\" : \"[]\" }", "docstring": "Together with :func:``update_last_applied_manifest_list_from_resp``, this\nfunction is called recursively to update a partial ``last_applied_manifest``\nfrom a partial Kubernetes response\n\nArgs:\n    last_applied_manifest (dict): partial ``last_applied_manifest`` being\n        updated\n    observer_schema (dict): partial ``observer_schema``\n    response (dict): partial response from the Kubernetes API.\n\nRaises:\n    KeyError: If the observed field is not present in the Kubernetes response\n\nThis function go through all observed fields, and initialized their value in\nlast_applied_manifest if they are not yet present", "correct_code": "def update_last_applied_manifest_dict_from_resp(\n    last_applied_manifest, observer_schema, response\n):\n    \"\"\"Together with :func:``update_last_applied_manifest_list_from_resp``, this\n    function is called recursively to update a partial ``last_applied_manifest``\n    from a partial Kubernetes response\n\n    Args:\n        last_applied_manifest (dict): partial ``last_applied_manifest`` being\n            updated\n        observer_schema (dict): partial ``observer_schema``\n        response (dict): partial response from the Kubernetes API.\n\n    Raises:\n        KeyError: If the observed field is not present in the Kubernetes response\n\n    This function go through all observed fields, and initialized their value in\n    last_applied_manifest if they are not yet present\n\n    \"\"\"\n    for key, value in observer_schema.items():\n\n        # Keys in the response are in camelCase\n        camel_key = camel_to_snake_case(key)\n\n        if camel_key not in response:\n            # An observed key should always be present in the k8s response\n            raise KeyError(\n                f\"Observed key {camel_key} is not present in response {response}\"\n            )\n\n        if isinstance(value, dict):\n            if key not in last_applied_manifest:\n                # The dictionary is observed, but not present in\n                # last_applied_manifest\n                last_applied_manifest[key] = {}\n\n            update_last_applied_manifest_dict_from_resp(\n                last_applied_manifest[key], observer_schema[key], response[camel_key]\n            )\n\n        elif isinstance(value, list):\n            if key not in last_applied_manifest:\n                # The list is observed, but not present in last_applied_manifest\n                last_applied_manifest[key] = []\n\n            update_last_applied_manifest_list_from_resp(\n                last_applied_manifest[key], observer_schema[key], response[camel_key]\n            )\n\n        elif key not in last_applied_manifest:\n            # If key not present in last_applied_manifest, and value is neither a\n            # dict nor a list, simply add it.\n            last_applied_manifest[key] = response[camel_key]\n"}
{"_id": "62b43427903eeb48555d3ea5", "fixed_results": [{"source": "rule_based", "false_code": "def format(self, sql: AnyStr, params: Union[Dict[Union[str, int], Any],\n    Sequence[Any]]) ->Tuple[AnyStr, Union[Dict[Union[str, int], Any],\n    Sequence[Any]]]:\n    \"\"\"\n    Convert the SQL query to use the out-style parameters instead of\n    the in-style parameters.\n\n    *sql* (:class:`str` or :class:`bytes`) is the SQL query.\n\n    *params* (:class:`~collections.abc.Mapping` or :class:`~collections.abc.Sequence`)\n    contains the set of in-style parameters. It maps each parameter\n    (:class:`str` or :class:`int`) to value. If :attr:`.SQLParams.in_style`\n    is a named parameter style. then *params* must be a :class:`~collections.abc.Mapping`.\n    If :attr:`.SQLParams.in_style` is an ordinal parameter style, then\n    *params* must be a :class:`~collections.abc.Sequence`.\n\n    Returns a :class:`tuple` containing:\n\n    -    The formatted SQL query (:class:`str` or :class:`bytes`).\n\n    -    The set of converted out-style parameters (:class:`dict` or\n        :class:`list`).\n    \"\"\"\n    if isinstance(sql, str):\n        use_sql = sql\n        string_type = str\n    elif isinstance(sql, bytes):\n        use_sql = sql.decode(_BYTES_ENCODING)\n        string_type = bytes\n    else:\n        raise TypeError('sql:{!r} is not a unicode or byte string.'.format(sql)\n            )\n    use_sql, out_params = self._converter.convert(use_sql, params)\n    if string_type <= bytes:\n        out_sql = use_sql.encode(_BYTES_ENCODING)\n    else:\n        out_sql = use_sql\n    return out_sql, out_params\n", "fixed_code": "from typing import AnyStr, Dict, Union, Sequence, Any, Tuple\n\ndef format(self, sql: AnyStr, params: Union[Dict[Union[str, int], Any],\n    Sequence[Any]]) ->Tuple[AnyStr, Union[Dict[Union[str, int], Any],\n    Sequence[Any]]]:\n    \"\"\"\n    Convert the SQL query to use the out-style parameters instead of\n    the in-style parameters.\n\n    *sql* (:class:`str` or :class:`bytes`) is the SQL query.\n\n    *params* (:class:`~collections.abc.Mapping` or :class:`~collections.abc.Sequence`)\n    contains the set of in-style parameters. It maps each parameter\n    (:class:`str` or :class:`int`) to value. If :attr:`.SQLParams.in_style`\n    is a named parameter style. then *params* must be a :class:`~collections.abc.Mapping`.\n    If :attr:`.SQLParams.in_style` is an ordinal parameter style, then\n    *params* must be a :class:`~collections.abc.Sequence`.\n\n    Returns a :class:`tuple` containing:\n\n    -    The formatted SQL query (:class:`str` or :class:`bytes`).\n\n    -    The set of converted out-style parameters (:class:`dict` or\n        :class:`list`).\n    \"\"\"\n    if isinstance(sql, str):\n        use_sql = sql\n        string_type = str\n    elif isinstance(sql, bytes):\n        use_sql = sql.decode(_BYTES_ENCODING)\n        string_type = bytes\n    else:\n        raise TypeError('sql:{!r} is not a unicode or byte string.'.format(sql))\n            \n    use_sql, out_params = self._converter.convert(use_sql, params)\n    if string_type is bytes:\n        out_sql = use_sql.encode(_BYTES_ENCODING)\n    else:\n        out_sql = use_sql\n    return out_sql, out_params"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['convert', 'encode', 'decode', 'isinstance']\", \"classes\" : \"['TypeError', 'Tuple']\", \"vars\" : \"['Str']\" }", "docstring": "Convert the SQL query to use the out-style parameters instead of\nthe in-style parameters.\n\n*sql* (:class:`str` or :class:`bytes`) is the SQL query.\n\n*params* (:class:`~collections.abc.Mapping` or :class:`~collections.abc.Sequence`)\ncontains the set of in-style parameters. It maps each parameter\n(:class:`str` or :class:`int`) to value. If :attr:`.SQLParams.in_style`\nis a named parameter style. then *params* must be a :class:`~collections.abc.Mapping`.\nIf :attr:`.SQLParams.in_style` is an ordinal parameter style, then\n*params* must be a :class:`~collections.abc.Sequence`.\n\nReturns a :class:`tuple` containing:\n\n-       The formatted SQL query (:class:`str` or :class:`bytes`).\n\n-       The set of converted out-style parameters (:class:`dict` or\n        :class:`list`).", "correct_code": "\tdef format(\n\t\tself,\n\t\tsql: AnyStr,\n\t\tparams: Union[Dict[Union[str, int], Any], Sequence[Any]],\n\t) -> Tuple[AnyStr, Union[Dict[Union[str, int], Any], Sequence[Any]]]:\n\t\t\"\"\"\n\t\tConvert the SQL query to use the out-style parameters instead of\n\t\tthe in-style parameters.\n\n\t\t*sql* (:class:`str` or :class:`bytes`) is the SQL query.\n\n\t\t*params* (:class:`~collections.abc.Mapping` or :class:`~collections.abc.Sequence`)\n\t\tcontains the set of in-style parameters. It maps each parameter\n\t\t(:class:`str` or :class:`int`) to value. If :attr:`.SQLParams.in_style`\n\t\tis a named parameter style. then *params* must be a :class:`~collections.abc.Mapping`.\n\t\tIf :attr:`.SQLParams.in_style` is an ordinal parameter style, then\n\t\t*params* must be a :class:`~collections.abc.Sequence`.\n\n\t\tReturns a :class:`tuple` containing:\n\n\t\t-\tThe formatted SQL query (:class:`str` or :class:`bytes`).\n\n\t\t-\tThe set of converted out-style parameters (:class:`dict` or\n\t\t\t:class:`list`).\n\t\t\"\"\"\n\t\t# Normalize query encoding to simplify processing.\n\t\tif isinstance(sql, str):\n\t\t\tuse_sql = sql\n\t\t\tstring_type = str\n\t\telif isinstance(sql, bytes):\n\t\t\tuse_sql = sql.decode(_BYTES_ENCODING)\n\t\t\tstring_type = bytes\n\t\telse:\n\t\t\traise TypeError(\"sql:{!r} is not a unicode or byte string.\".format(sql))\n\n\t\t# Replace in-style with out-style parameters.\n\t\tuse_sql, out_params = self._converter.convert(use_sql, params)\n\n\t\t# Make sure the query is returned as the proper string type.\n\t\tif string_type is bytes:\n\t\t\tout_sql = use_sql.encode(_BYTES_ENCODING)\n\t\telse:\n\t\t\tout_sql = use_sql\n\n\t\t# Return converted SQL and out-parameters.\n\t\treturn out_sql, out_params\n"}
{"_id": "62b43428903eeb48555d3eaa", "fixed_results": [{"source": "existing", "false_code": "from typing import AnyStr, Dict, Iterable, List, Sequence, Tuple, Union\n\nclass MyClass:\n    def formatmany(\n        self,\n        sql: AnyStr,\n        many_params: Union[Iterable[Dict[Union[str, int], Any]], Iterable[Sequence[Any]]],\n    ) -> Tuple[AnyStr, Union[List[Dict[Union[str, int], Any]], List[Sequence[Any]]]]:\n        pass", "fixed_code": "from typing import Any, Dict, Iterable, List, Sequence, Tuple, Union\n\nclass MyClass:\n    def formatmany(\n        self,\n        sql: Union[str, bytes],\n        many_params: Union[Iterable[Dict[Union[str, int], Any]], Iterable[Sequence[Any]]],\n    ) -> Tuple[Union[str, bytes], Union[List[Dict[Union[str, int], Any]], List[Sequence[Any]]]]:\n        pass"}], "level": "project_runnable", "oracle_context": "{ \"apis\" : \"['convert_many', 'format', '_is_iterable', 'isinstance', 'decode', 'encode']\", \"classes\" : \"['TypeError', 'Tuple']\", \"vars\" : \"['Str']\" }", "docstring": "Convert the SQL query to use the out-style parameters instead of the\nin-style parameters.\n\n*sql* (:class:`str` or :class:`bytes`) is the SQL query.\n\n*many_params* (:class:`~collections.abc.Iterable`) contains each set\nof in-style parameters (*params*).\n\n-       *params* (:class:`~collections.abc.Mapping` or :class:`~collections.abc.Sequence`)\n        contains the set of in-style parameters. It maps each parameter\n        (:class:`str` or :class:`int`) to value. If :attr:`.SQLParams.in_style`\n        is a named parameter style. then *params* must be a :class:`~collections.abc.Mapping`.\n        If :attr:`.SQLParams.in_style` is an ordinal parameter style. then\n        *params* must be a :class:`~collections.abc.Sequence`.\n\nReturns a :class:`tuple` containing:\n\n-       The formatted SQL query (:class:`str` or :class:`bytes`).\n\n-       A :class:`list` containing each set of converted out-style\n        parameters (:class:`dict` or :class:`list`).", "correct_code": "\tdef formatmany(\n\t\tself,\n\t\tsql: AnyStr,\n\t\tmany_params: Union[Iterable[Dict[Union[str, int], Any]], Iterable[Sequence[Any]]],\n\t) -> Tuple[AnyStr, Union[List[Dict[Union[str, int], Any]], List[Sequence[Any]]]]:\n\t\t\"\"\"\n\t\tConvert the SQL query to use the out-style parameters instead of the\n\t\tin-style parameters.\n\n\t\t*sql* (:class:`str` or :class:`bytes`) is the SQL query.\n\n\t\t*many_params* (:class:`~collections.abc.Iterable`) contains each set\n\t\tof in-style parameters (*params*).\n\n\t\t-\t*params* (:class:`~collections.abc.Mapping` or :class:`~collections.abc.Sequence`)\n\t\t\tcontains the set of in-style parameters. It maps each parameter\n\t\t\t(:class:`str` or :class:`int`) to value. If :attr:`.SQLParams.in_style`\n\t\t\tis a named parameter style. then *params* must be a :class:`~collections.abc.Mapping`.\n\t\t\tIf :attr:`.SQLParams.in_style` is an ordinal parameter style. then\n\t\t\t*params* must be a :class:`~collections.abc.Sequence`.\n\n\t\tReturns a :class:`tuple` containing:\n\n\t\t-\tThe formatted SQL query (:class:`str` or :class:`bytes`).\n\n\t\t-\tA :class:`list` containing each set of converted out-style\n\t\t\tparameters (:class:`dict` or :class:`list`).\n\t\t\"\"\"\n\t\t# Normalize query encoding to simplify processing.\n\t\tif isinstance(sql, str):\n\t\t\tuse_sql = sql\n\t\t\tstring_type = str\n\t\telif isinstance(sql, bytes):\n\t\t\tuse_sql = sql.decode(_BYTES_ENCODING)\n\t\t\tstring_type = bytes\n\t\telse:\n\t\t\traise TypeError(\"sql:{!r} is not a unicode or byte string.\".format(sql))\n\n\t\tif not _is_iterable(many_params):\n\t\t\traise TypeError(\"many_params:{!r} is not iterable.\".format(many_params))\n\n\t\t# Replace in-style with out-style parameters.\n\t\tuse_sql, many_out_params = self._converter.convert_many(use_sql, many_params)\n\n\t\t# Make sure the query is returned as the proper string type.\n\t\tif string_type is bytes:\n\t\t\tout_sql = use_sql.encode(_BYTES_ENCODING)\n\t\telse:\n\t\t\tout_sql = use_sql\n\n\t\t# Return converted SQL and out-parameters.\n\t\treturn out_sql, many_out_params\n"}
{"_id": "62b45df05108cfac7f2109ce", "fixed_results": [{"source": "llm-based", "false_code": "def validate(self, path):\n    \"\"\"Validate OCFL object at path or pyfs root.\n\n    Returns True if valid (warnings permitted), False otherwise.\n    \"\"\"\n    self.initialize()\n    try:\n        if isinstance(path, str):\n            self.obj_fs = open_fs(path)\n        else:\n            self.obj_fs = path\n            path = self.obj_fs.desc('')\n    except fs.errors.CreateFailed:\n        self.log.error('E003e', path=path)\n        return True  # Mutant: changed return value from False to True\n    # Object declaration, set spec version number. If there are multiple declarations,\n    # look for the lastest object version then report any others as errors\n    namastes = find_namastes(0, pyfs=self.obj_fs)\n    if len(namastes) == 0:\n        self.log.error('E003a', assumed_version=self.spec_version)\n    else:\n        spec_version = None\n        for namaste in namastes:\n            # Extract and check spec version number\n            this_file_version = None\n            for version in ('1.1', '1.0'):\n                if namaste.filename == '0=ocfl_object_' + version:\n                    this_file_version = version\n                    break\n            if this_file_version is None:\n                self.log.error('E006', filename=namaste.filename)\n            elif spec_version is None or this_file_version < spec_version:  # Mutant: changed '>' to '<'\n                spec_version = this_file_version\n                if not namaste.content_ok(pyfs=self.obj_fs):\n                    self.log.error('E007', filename=namaste.filename)\n        if spec_version is None:\n            self.log.error('E003c', assumed_version=self.spec_version)\n        else:\n            self.spec_version = spec_version\n            if len(namastes) == 1:  # Mutant: changed '>' to '=='\n                self.log.error('E003b', files=len(namastes), using_version=self.spec_version)\n    # Object root inventory file\n    inv_file = 'inventory.json'\n    if not self.obj_fs.exists(inv_file):\n        self.log.error('E063')\n        return False\n    try:\n        inventory, inv_validator = self.validate_inventory(inv_file)\n        inventory_is_valid = self.log.num_errors != 0  # Mutant: inverted the condition\n        self.root_inv_validator = inv_validator\n        all_versions = inv_validator.all_versions\n        self.id = inv_validator.id\n        self.content_directory = inv_validator.content_directory\n        self.digest_algorithm = inv_validator.digest_algorithm\n        self.validate_inventory_digest(inv_file, self.digest_algorithm)\n        # Object root\n        self.validate_object_root(all_versions, already_checked=[namaste.filename for namaste in namastes])\n        # Version inventory files\n        (prior_manifest_digests, prior_fixity_digests) = self.validate_version_inventories(all_versions)\n        if inventory_is_valid:\n            # Object content\n            self.validate_content(inventory, all_versions, prior_manifest_digests, prior_fixity_digests)\n    except ValidatorAbortException:\n        pass\n    return self.log.num_errors != 0  # Mutant: inverted return condition", "fixed_code": "def validate(self, path):\n    \"\"\"Validate OCFL object at path or pyfs root.\n\n    Returns True if valid (warnings permitted), False otherwise.\n    \"\"\"\n    self.initialize()\n    try:\n        if isinstance(path, str):\n            self.obj_fs = open_fs(path)\n        else:\n            self.obj_fs = path\n            path = self.obj_fs.desc('')\n    except fs.errors.CreateFailed:\n        self.log.error('E003e', path=path)\n        return False  # Fixed: Return False on CreateFailed error\n    \n    # Object declaration, set spec version number\n    namastes = find_namastes(0, pyfs=self.obj_fs)\n    if len(namastes) == 0:\n        self.log.error('E003a', assumed_version=self.spec_version)\n    else:\n        spec_version = None\n        for namaste in namastes:\n            # Extract and check spec version number\n            this_file_version = None\n            for version in ('1.1', '1.0'):\n                if namaste.filename == '0=ocfl_object_' + version:\n                    this_file_version = version\n                    break\n            if this_file_version is None:\n                self.log.error('E006', filename=namaste.filename)\n            elif spec_version is None or this_file_version > spec_version:  # Fixed: Changed '<' to '>'\n                spec_version = this_file_version\n                if not namaste.content_ok(pyfs=self.obj_fs):\n                    self.log.error('E007', filename=namaste.filename)\n        if spec_version is None:\n            self.log.error('E003c', assumed_version=self.spec_version)\n        else:\n            self.spec_version = spec_version\n            if len(namastes) > 1:  # Fixed: Changed '==' to '>'\n                self.log.error('E003b', files=len(namastes), using_version=self.spec_version)\n    \n    # Object root inventory file\n    inv_file = 'inventory.json'\n    if not self.obj_fs.exists(inv_file):\n        self.log.error('E063')\n        return False\n    \n    try:\n        inventory, inv_validator = self.validate_inventory(inv_file)\n        inventory_is_valid = self.log.num_errors == 0  # Fixed: Corrected condition\n        self.root_inv_validator = inv_validator\n        all_versions = inv_validator.all_versions\n        self.id = inv_validator.id\n        self.content_directory = inv_validator.content_directory\n        self.digest_algorithm = inv_validator.digest_algorithm\n        self.validate_inventory_digest(inv_file, self.digest_algorithm)\n        \n        # Object root\n        self.validate_object_root(all_versions, already_checked=[namaste.filename for namaste in namastes])\n        \n        # Version inventory files\n        (prior_manifest_digests, prior_fixity_digests) = self.validate_version_inventories(all_versions)\n        \n        if inventory_is_valid:\n            # Object content\n            if isinstance(inventory, dict) and 'manifest' in inventory:  # Added validation\n                self.validate_content(inventory, all_versions, prior_manifest_digests, prior_fixity_digests)\n    except ValidatorAbortException:\n        pass\n    \n    return self.log.num_errors == 0  # Fixed: Corrected return condition"}], "level": "class_runnable", "oracle_context": "{ \"apis\" : \"['validate_content', 'find_namastes', 'open_fs', 'exists', 'content_ok', 'desc', 'error', 'validate_object_root', 'initialize', 'validate_inventory_digest', 'validate_version_inventories', 'isinstance', 'validate_inventory', 'len']\", \"classes\" : \"['find_namastes']\", \"vars\" : \"[]\" }", "docstring": "Validate OCFL object at path or pyfs root.\n\nReturns True if valid (warnings permitted), False otherwise.", "correct_code": "    def validate(self, path):\n        \"\"\"Validate OCFL object at path or pyfs root.\n\n        Returns True if valid (warnings permitted), False otherwise.\n        \"\"\"\n        self.initialize()\n        try:\n            if isinstance(path, str):\n                self.obj_fs = open_fs(path)\n            else:\n                self.obj_fs = path\n                path = self.obj_fs.desc('')\n        except fs.errors.CreateFailed:\n            self.log.error('E003e', path=path)\n            return False\n        # Object declaration, set spec version number. If there are multiple declarations,\n        # look for the lastest object version then report any others as errors\n        namastes = find_namastes(0, pyfs=self.obj_fs)\n        if len(namastes) == 0:\n            self.log.error('E003a', assumed_version=self.spec_version)\n        else:\n            spec_version = None\n            for namaste in namastes:\n                # Extract and check spec version number\n                this_file_version = None\n                for version in ('1.1', '1.0'):\n                    if namaste.filename == '0=ocfl_object_' + version:\n                        this_file_version = version\n                        break\n                if this_file_version is None:\n                    self.log.error('E006', filename=namaste.filename)\n                elif spec_version is None or this_file_version > spec_version:\n                    spec_version = this_file_version\n                    if not namaste.content_ok(pyfs=self.obj_fs):\n                        self.log.error('E007', filename=namaste.filename)\n            if spec_version is None:\n                self.log.error('E003c', assumed_version=self.spec_version)\n            else:\n                self.spec_version = spec_version\n                if len(namastes) > 1:\n                    self.log.error('E003b', files=len(namastes), using_version=self.spec_version)\n        # Object root inventory file\n        inv_file = 'inventory.json'\n        if not self.obj_fs.exists(inv_file):\n            self.log.error('E063')\n            return False\n        try:\n            inventory, inv_validator = self.validate_inventory(inv_file)\n            inventory_is_valid = self.log.num_errors == 0\n            self.root_inv_validator = inv_validator\n            all_versions = inv_validator.all_versions\n            self.id = inv_validator.id\n            self.content_directory = inv_validator.content_directory\n            self.digest_algorithm = inv_validator.digest_algorithm\n            self.validate_inventory_digest(inv_file, self.digest_algorithm)\n            # Object root\n            self.validate_object_root(all_versions, already_checked=[namaste.filename for namaste in namastes])\n            # Version inventory files\n            (prior_manifest_digests, prior_fixity_digests) = self.validate_version_inventories(all_versions)\n            if inventory_is_valid:\n                # Object content\n                self.validate_content(inventory, all_versions, prior_manifest_digests, prior_fixity_digests)\n        except ValidatorAbortException:\n            pass\n        return self.log.num_errors == 0\n"}
{"_id": "62b45e145108cfac7f210a07", "fixed_results": [{"source": "llm-based", "false_code": "def validate(self, inventory, extract_spec_version=False):\n    \"\"\"Validate a given inventory.\n\n    If extract_spec_version is True then will look at the type value to determine\n    the specification version. In the case that there is no type value or it isn't\n    valid, then other tests will be based on the version given in self.spec_version.\n    \"\"\"\n    # Basic structure\n    self.inventory = inventory\n    if 'id' in inventory:\n        iid = inventory['id']\n        if not isinstance(iid, str) or iid == '':\n            self.error(\"E037a\")\n        else:\n            # URI syntax https://www.rfc-editor.org/rfc/rfc3986.html#section-3.1 :\n            # scheme = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n            if not re.match(r'''[a-z][a-z\\d\\+\\-\\.]*:.+''', iid, re.IGNORECASE):\n                self.warning(\"W005\", id=iid)\n            self.id = iid\n    else:\n        self.error(\"E036a\")\n    if 'type' not in inventory:\n        self.error(\"E036b\")\n    elif not isinstance(inventory['type'], str):\n        self.error(\"E999\")\n    elif extract_spec_version:\n        m = re.match(r'''https://ocfl.io/(\\d+.\\d)/spec/#inventory''', inventory['type'])\n        if not m:\n            self.error('E038b', got=inventory['type'], assumed_spec_version=self.spec_version)\n        elif m.group(1) in self.spec_versions_supported:\n            self.spec_version = m.group(1)\n        else:\n            self.error(\"E038c\", got=m.group(1), assumed_spec_version=self.spec_version)\n    elif inventory['type'] != 'https://ocfl.io/' + self.spec_version + '/spec/#inventory':\n        self.error(\"E038a\", expected='https://ocfl.io/' + self.spec_version + '/spec/#inventory', got=inventory['type'])\n    if 'digestAlgorithm' not in inventory:\n        self.error(\"E036c\")\n    elif inventory['digestAlgorithm'] == 'sha256':  # Changed from 'sha512' to 'sha256'\n        pass\n    elif self.lax_digests:\n        self.digest_algorithm = inventory['digestAlgorithm']\n    elif inventory['digestAlgorithm'] == 'sha256':\n        self.warning(\"W004\")\n        self.digest_algorithm = inventory['digestAlgorithm']\n    else:\n        self.error(\"E039\", digest_algorithm=inventory['digestAlgorithm'])\n    if 'contentDirectory' in inventory:\n        # Careful only to set self.content_directory if value is safe\n        cd = inventory['contentDirectory']\n        if not isinstance(cd, str) or '/' in cd:\n            self.error(\"E017\")\n        elif cd in ('.', '..'):\n            self.error(\"E018\")\n        else:\n            self.content_directory = cd\n    manifest_files_correct_format = None\n    if 'manifest' not in inventory:\n        self.error(\"E041a\")\n    else:\n        (self.manifest_files, manifest_files_correct_format, self.unnormalized_digests) = self.validate_manifest(inventory['manifest'])\n    digests_used = []\n    if 'versions' not in inventory:\n        self.error(\"E041b\")\n    else:\n        self.all_versions = self.validate_version_sequence(inventory['versions'])\n        digests_used = self.validate_versions(inventory['versions'], self.all_versions, self.unnormalized_digests)\n    if 'head' not in inventory:\n        self.error(\"E036d\")\n    elif len(self.all_versions) > 0:\n        self.head = self.all_versions[-1]\n        if inventory['head'] != self.head:\n            self.error(\"E040\", got=inventory['head'], expected=self.head)\n    if len(self.all_versions) == 0:\n        # Abort tests is we don't have a valid version sequence, otherwise\n        # there will likely be spurious subsequent error reports\n        return\n    if len(self.all_versions) > 0:\n        if manifest_files_correct_format is not None:\n            self.check_content_paths_map_to_versions(manifest_files_correct_format, self.all_versions)\n        if self.manifest_files is not None:\n            self.check_digests_present_and_used(self.manifest_files, digests_used)\n    if 'fixity' in inventory:\n        self.validate_fixity(inventory['fixity'], self.manifest_files)", "fixed_code": "def validate(self, inventory, extract_spec_version=False):\n    \"\"\"Validate a given inventory.\n\n    If extract_spec_version is True then will look at the type value to determine\n    the specification version. In the case that there is no type value or it isn't\n    valid, then other tests will be based on the version given in self.spec_version.\n    \"\"\"\n    # Basic structure\n    self.inventory = inventory\n    if 'id' in inventory:\n        iid = inventory['id']\n        if not isinstance(iid, str) or iid == '':\n            self.error(\"E037a\")\n        else:\n            # URI syntax https://www.rfc-editor.org/rfc/rfc3986.html#section-3.1 :\n            # scheme = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n            if not re.match(r'''[a-z][a-z\\d\\+\\-\\.]*:.+''', iid, re.IGNORECASE):\n                self.warning(\"W005\", id=iid)\n            self.id = iid\n    else:\n        self.error(\"E036a\")\n    \n    if 'type' not in inventory:\n        self.error(\"E036b\")\n    elif not isinstance(inventory['type'], str):\n        self.error(\"E999\")\n    elif extract_spec_version:\n        m = re.match(r'''https://ocfl.io/(\\d+.\\d)/spec/#inventory''', inventory['type'])\n        if not m:\n            self.error('E038b', got=inventory['type'], assumed_spec_version=self.spec_version)\n        elif m.group(1) in self.spec_versions_supported:\n            self.spec_version = m.group(1)\n        else:\n            self.error(\"E038c\", got=m.group(1), assumed_spec_version=self.spec_version)\n    elif inventory['type'] != 'https://ocfl.io/' + self.spec_version + '/spec/#inventory':\n        self.error(\"E038a\", expected='https://ocfl.io/' + self.spec_version + '/spec/#inventory', got=inventory['type'])\n    \n    if 'digestAlgorithm' not in inventory:\n        self.error(\"E036c\")\n    elif inventory['digestAlgorithm'] == 'sha512':  # Primary recommended algorithm\n        self.digest_algorithm = inventory['digestAlgorithm']\n    elif inventory['digestAlgorithm'] == 'sha256':  # Secondary supported algorithm\n        self.warning(\"W004\")\n        self.digest_algorithm = inventory['digestAlgorithm']\n    elif self.lax_digests:\n        self.digest_algorithm = inventory['digestAlgorithm']\n    else:\n        self.error(\"E039\", digest_algorithm=inventory['digestAlgorithm'])\n    \n    if 'contentDirectory' in inventory:\n        # Careful only to set self.content_directory if value is safe\n        cd = inventory['contentDirectory']\n        if not isinstance(cd, str) or '/' in cd:\n            self.error(\"E017\")\n        elif cd in ('.', '..'):\n            self.error(\"E018\")\n        else:\n            self.content_directory = cd\n    \n    manifest_files_correct_format = None\n    if 'manifest' not in inventory:\n        self.error(\"E041a\")\n    else:\n        (self.manifest_files, manifest_files_correct_format, self.unnormalized_digests) = self.validate_manifest(inventory['manifest'])\n    \n    digests_used = []\n    if 'versions' not in inventory:\n        self.error(\"E041b\")\n    else:\n        self.all_versions = self.validate_version_sequence(inventory['versions'])\n        digests_used = self.validate_versions(inventory['versions'], self.all_versions, self.unnormalized_digests)\n    \n    if 'head' not in inventory:\n        self.error(\"E036d\")\n    elif len(self.all_versions) > 0:\n        self.head = self.all_versions[-1]\n        if inventory['head'] != self.head:\n            self.error(\"E040\", got=inventory['head'], expected=self.head)\n    \n    if len(self.all_versions) == 0:\n        # Abort tests if we don't have a valid version sequence, otherwise\n        # there will likely be spurious subsequent error reports\n        return\n    \n    if manifest_files_correct_format is not None:\n        self.check_content_paths_map_to_versions(manifest_files_correct_format, self.all_versions)\n    if self.manifest_files is not None:\n        self.check_digests_present_and_used(self.manifest_files, digests_used)\n    \n    if 'fixity' in inventory:\n        self.validate_fixity(inventory['fixity'], self.manifest_files)"}], "level": "class_runnable", "oracle_context": "{ \"apis\" : \"['warning', 'check_digests_present_and_used', 'validate_manifest', 'check_content_paths_map_to_versions', 'error', 'match', 'validate_fixity', 'validate_versions', 'validate_version_sequence', 'group', 'isinstance', 'len']\", \"classes\" : \"['re']\", \"vars\" : \"[]\" }", "docstring": "Validate a given inventory.\n\nIf extract_spec_version is True then will look at the type value to determine\nthe specification version. In the case that there is no type value or it isn't\nvalid, then other tests will be based on the version given in self.spec_version.", "correct_code": "    def validate(self, inventory, extract_spec_version=False):\n        \"\"\"Validate a given inventory.\n\n        If extract_spec_version is True then will look at the type value to determine\n        the specification version. In the case that there is no type value or it isn't\n        valid, then other tests will be based on the version given in self.spec_version.\n        \"\"\"\n        # Basic structure\n        self.inventory = inventory\n        if 'id' in inventory:\n            iid = inventory['id']\n            if not isinstance(iid, str) or iid == '':\n                self.error(\"E037a\")\n            else:\n                # URI syntax https://www.rfc-editor.org/rfc/rfc3986.html#section-3.1 :\n                # scheme = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n                if not re.match(r'''[a-z][a-z\\d\\+\\-\\.]*:.+''', iid, re.IGNORECASE):\n                    self.warning(\"W005\", id=iid)\n                self.id = iid\n        else:\n            self.error(\"E036a\")\n        if 'type' not in inventory:\n            self.error(\"E036b\")\n        elif not isinstance(inventory['type'], str):\n            self.error(\"E999\")\n        elif extract_spec_version:\n            m = re.match(r'''https://ocfl.io/(\\d+.\\d)/spec/#inventory''', inventory['type'])\n            if not m:\n                self.error('E038b', got=inventory['type'], assumed_spec_version=self.spec_version)\n            elif m.group(1) in self.spec_versions_supported:\n                self.spec_version = m.group(1)\n            else:\n                self.error(\"E038c\", got=m.group(1), assumed_spec_version=self.spec_version)\n        elif inventory['type'] != 'https://ocfl.io/' + self.spec_version + '/spec/#inventory':\n            self.error(\"E038a\", expected='https://ocfl.io/' + self.spec_version + '/spec/#inventory', got=inventory['type'])\n        if 'digestAlgorithm' not in inventory:\n            self.error(\"E036c\")\n        elif inventory['digestAlgorithm'] == 'sha512':\n            pass\n        elif self.lax_digests:\n            self.digest_algorithm = inventory['digestAlgorithm']\n        elif inventory['digestAlgorithm'] == 'sha256':\n            self.warning(\"W004\")\n            self.digest_algorithm = inventory['digestAlgorithm']\n        else:\n            self.error(\"E039\", digest_algorithm=inventory['digestAlgorithm'])\n        if 'contentDirectory' in inventory:\n            # Careful only to set self.content_directory if value is safe\n            cd = inventory['contentDirectory']\n            if not isinstance(cd, str) or '/' in cd:\n                self.error(\"E017\")\n            elif cd in ('.', '..'):\n                self.error(\"E018\")\n            else:\n                self.content_directory = cd\n        manifest_files_correct_format = None\n        if 'manifest' not in inventory:\n            self.error(\"E041a\")\n        else:\n            (self.manifest_files, manifest_files_correct_format, self.unnormalized_digests) = self.validate_manifest(inventory['manifest'])\n        digests_used = []\n        if 'versions' not in inventory:\n            self.error(\"E041b\")\n        else:\n            self.all_versions = self.validate_version_sequence(inventory['versions'])\n            digests_used = self.validate_versions(inventory['versions'], self.all_versions, self.unnormalized_digests)\n        if 'head' not in inventory:\n            self.error(\"E036d\")\n        elif len(self.all_versions) > 0:\n            self.head = self.all_versions[-1]\n            if inventory['head'] != self.head:\n                self.error(\"E040\", got=inventory['head'], expected=self.head)\n        if len(self.all_versions) == 0:\n            # Abort tests is we don't have a valid version sequence, otherwise\n            # there will likely be spurious subsequent error reports\n            return\n        if len(self.all_versions) > 0:\n            if manifest_files_correct_format is not None:\n                self.check_content_paths_map_to_versions(manifest_files_correct_format, self.all_versions)\n            if self.manifest_files is not None:\n                self.check_digests_present_and_used(self.manifest_files, digests_used)\n        if 'fixity' in inventory:\n            self.validate_fixity(inventory['fixity'], self.manifest_files)\n"}
{"_id": "62b45e145108cfac7f210a09", "fixed_results": [{"source": "existing", "false_code": "def check_digests_present_and_used(self, manifest_files: List[str], digests_used: List[str]) -> None:\n    \"\"\"\n    Check all digests in manifest that are needed are present and used. Return error() in the class.\n    \"\"\"\n    pass", "fixed_code": "from typing import List\n\ndef check_digests_present_and_used(self, manifest_files: List[str], digests_used: List[str]) -> None:\n    \"\"\"\n    Check all digests in manifest that are needed are present and used. Return error() in the class.\n    \"\"\"\n    # Convert lists to sets for efficient comparison\n    manifest_set = set(manifest_files)\n    digests_set = set(digests_used)\n    \n    # Find digests that are in manifest but not used\n    unused_digests = manifest_set.difference(digests_set)\n    \n    # Find digests that are used but not in manifest\n    missing_digests = digests_set.difference(manifest_set)\n    \n    # Check for any discrepancies\n    if len(unused_digests) > 0:\n        self.error(f\"Digests present in manifest but not used: {', '.join(sorted(unused_digests))}\")\n    \n    if len(missing_digests) > 0:\n        self.error(f\"Digests used but not present in manifest: {', '.join(sorted(missing_digests))}\")"}], "level": "class_runnable", "oracle_context": "{ \"apis\" : \"['sorted', 'error', 'values', 'difference', 'join', 'set', 'len']\", \"classes\" : \"[]\", \"vars\" : \"['Str']\" }", "docstring": "Check all digests in manifest that are needed are present and used.", "correct_code": "    def check_digests_present_and_used(self, manifest_files, digests_used):\n        \"\"\"Check all digests in manifest that are needed are present and used.\"\"\"\n        in_manifest = set(manifest_files.values())\n        in_state = set(digests_used)\n        not_in_manifest = in_state.difference(in_manifest)\n        if len(not_in_manifest) > 0:\n            self.error(\"E050a\", digests=\", \".join(sorted(not_in_manifest)))\n        not_in_state = in_manifest.difference(in_state)\n        if len(not_in_state) > 0:\n            self.error(\"E107\", digests=\", \".join(sorted(not_in_state)))\n"}
{"_id": "62b45e165108cfac7f210a16", "fixed_results": [{"source": "existing", "false_code": "def validate_as_prior_version(self, prior):\n    return self.error()", "fixed_code": "def validate_as_prior_version(self, prior):\n    # Get logical path maps for both versions\n    this_map = self.get_logical_path_map()\n    prior_map = prior.get_logical_path_map()\n    \n    # Check that all items in prior version exist in current version\n    if not set(prior_map.keys()).issubset(set(this_map.keys())):\n        missing = set(prior_map.keys()) - set(this_map.keys())\n        return self.error(\"invalid_state\", \n                         f\"Prior version contains paths not in current version: {', '.join(missing)}\")\n    \n    # Compare states between versions\n    for path in prior_map.keys():\n        if not self.compare_states_for_version(prior, path):\n            return self.error(\"invalid_state\",\n                            f\"State mismatch for path: {path}\")\n    \n    return True"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['warning', 'error', 'items', 'issubset', 'join', 'get_logical_path_map', 'get', 'compare_states_for_version', 'set', 'keys']\", \"classes\" : \"[]\", \"vars\" : \"['Str', 'this_map']\" }", "docstring": "Check that prior is a valid prior version of the current inventory object.\n\nThe input variable prior is also expected to be an InventoryValidator object\nand both self and prior inventories are assumed to have been checked for\ninternal consistency.", "correct_code": "    def validate_as_prior_version(self, prior):\n        \"\"\"Check that prior is a valid prior version of the current inventory object.\n\n        The input variable prior is also expected to be an InventoryValidator object\n        and both self and prior inventories are assumed to have been checked for\n        internal consistency.\n        \"\"\"\n        # Must have a subset of versions which also checks zero padding format etc.\n        if not set(prior.all_versions) < set(self.all_versions):\n            self.error('E066a', prior_head=prior.head)\n        else:\n            # Check references to files but realize that there might be different\n            # digest algorithms between versions\n            version = 'no-version'\n            for version in prior.all_versions:\n                # If the digest algorithm is the same then we can make a\n                # direct check on whether the state blocks match\n                if prior.digest_algorithm == self.digest_algorithm:\n                    self.compare_states_for_version(prior, version)\n                # Now check the mappings from state to logical path, which must\n                # be consistent even if the digestAlgorithm is different between\n                # versions. Get maps from logical paths to files on disk:\n                prior_map = get_logical_path_map(prior.inventory, version)\n                self_map = get_logical_path_map(self.inventory, version)\n                # Look first for differences in logical paths listed\n                only_in_prior = prior_map.keys() - self_map.keys()\n                only_in_self = self_map.keys() - prior_map.keys()\n                if only_in_prior or only_in_self:\n                    if only_in_prior:\n                        self.error('E066b', version=version, prior_head=prior.head, only_in=prior.head, logical_paths=','.join(only_in_prior))\n                    if only_in_self:\n                        self.error('E066b', version=version, prior_head=prior.head, only_in=self.where, logical_paths=','.join(only_in_self))\n                else:\n                    # Check them all in details - digests must match\n                    for logical_path, this_map in prior_map.items():\n                        if not this_map.issubset(self_map[logical_path]):\n                            self.error('E066c', version=version, prior_head=prior.head,\n                                       logical_path=logical_path, prior_content=','.join(this_map),\n                                       current_content=','.join(self_map[logical_path]))\n                # Check metadata\n                prior_version = prior.inventory['versions'][version]\n                self_version = self.inventory['versions'][version]\n                for key in ('created', 'message', 'user'):\n                    if prior_version.get(key) != self_version.get(key):\n                        self.warning('W011', version=version, prior_head=prior.head, key=key)\n"}
{"_id": "62b463153879012d19481498", "fixed_results": [{"source": "rule_based", "false_code": "def files_list(path):\n    \"\"\"\n    Return the files in `path`\n    \"\"\"\n    return os.listdir()\n", "fixed_code": "def files_list(path):\n    \"\"\"\n    Return the files in `path`\n    \"\"\"\n    return os.listdir(path)"}], "level": "slib_runnable", "oracle_context": "{ \"apis\" : \"['listdir']\", \"classes\" : \"['os']\", \"vars\" : \"[]\" }", "docstring": "Return the files in `path`", "correct_code": "def files_list(path):\n    \"\"\"\n    Return the files in `path`\n    \"\"\"\n    return os.listdir(path)\n"}
{"_id": "62b463153879012d1948149d", "fixed_results": [{"source": "existing", "false_code": "def _explore_folder(folder: str) -> None:\n    \"\"\"\n    Groups files in the given group by using _group_files_by_xml_filename.\n    \"\"\"\n    pass", "fixed_code": "def _explore_folder(folder: str) -> dict:\n    \"\"\"\n    Get packages' data from folder\n\n    Groups files by their XML basename and returns data in dict format.\n\n    Parameters\n    ----------\n    folder : str\n        Folder of the package\n    Returns\n    -------\n    dict\n    \"\"\"\n    if not is_folder(folder):\n        raise ValueError(f\"Invalid folder path: {folder}\")\n    \n    xml_files = xml_files_list(folder)\n    if not xml_files:\n        return {}\n        \n    grouped_files = _group_files_by_xml_filename(folder)\n    return grouped_files"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['_group_files_by_xml_filename', 'xml_files_list', 'is_folder', 'files_list']\", \"classes\" : \"['file_utils']\", \"vars\" : \"[]\" }", "docstring": "Get packages' data from folder\n\nGroups files by their XML basename and returns data in dict format.\n\nParameters\n----------\nfolder : str\n    Folder of the package\nReturns\n-------\ndict", "correct_code": "def _explore_folder(folder):\n    \"\"\"\n    Get packages' data from folder\n\n    Groups files by their XML basename and returns data in dict format.\n\n    Parameters\n    ----------\n    folder : str\n        Folder of the package\n    Returns\n    -------\n    dict\n    \"\"\"\n    if file_utils.is_folder(folder):\n        data = _group_files_by_xml_filename(\n            folder,\n            file_utils.xml_files_list(folder),\n            file_utils.files_list(folder),\n        )\n        return data\n"}
{"_id": "62b463153879012d194814a1", "fixed_results": [{"source": "rule_based", "false_code": "def add_rendition(self, lang, file_path):\n    \"\"\"\n    {\n        \"original\": \"artigo02.pdf\",\n        \"en\": \"artigo02-en.pdf\",\n    }\n    \"\"\"\n    self._renditions[lang] = self.file_path()\n", "fixed_code": "def add_rendition(self, lang, file_path):\n    \"\"\"\n    {\n        \"original\": \"artigo02.pdf\",\n        \"en\": \"artigo02-en.pdf\",\n    }\n    \"\"\"\n    self._renditions[lang] = file_path"}], "level": "class_runnable", "oracle_context": "{ \"apis\" : \"['file_path']\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": "{\n    \"original\": \"artigo02.pdf\",\n    \"en\": \"artigo02-en.pdf\",\n}", "correct_code": "    def add_rendition(self, lang, file_path):\n        \"\"\"\n        {\n            \"original\": \"artigo02.pdf\",\n            \"en\": \"artigo02-en.pdf\",\n        }\n        \"\"\"\n        self._renditions[lang] = self.file_path(file_path)\n"}
{"_id": "62b463163879012d194814a4", "fixed_results": [{"source": "existing", "false_code": "from typing import List\n\ndef _explore_zipfile(zip_path: str) -> List[str]:\n    def _group_files_by_xml_filename(file_list: List[str]) -> List[List[str]]:\n        # Implementation of _group_files_by_xml_filename function\n        pass\n    \n    # Implementation of _explore_zipfile function\n    pass", "fixed_code": "from typing import List\nfrom zipfile import is_zipfile\n\ndef _explore_zipfile(zip_path: str) -> dict:\n    def _group_files_by_xml_filename(file_list: List[str]) -> dict:\n        \"\"\"Group files by their XML basename.\n        \n        Args:\n            file_list: List of filenames from zip\n            \n        Returns:\n            Dictionary with XML basename as key and list of related files as value\n        \"\"\"\n        result = {}\n        for file in file_list:\n            if file.endswith('.xml'):\n                base_name = file.rsplit('.', 1)[0]\n                result[base_name] = [f for f in file_list if f.startswith(base_name)]\n        return result\n    \n    # Validate zip file\n    if not is_zipfile(zip_path):\n        return {}\n    \n    # Get all files from zip\n    all_files = files_list_from_zipfile(zip_path)\n    \n    # Group files by XML basename\n    grouped_files = _group_files_by_xml_filename(all_files)\n    \n    return grouped_files"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['xml_files_list_from_zipfile', '_group_files_by_xml_filename', 'is_zipfile', 'files_list_from_zipfile']\", \"classes\" : \"['ZipFile', 'file_utils']\", \"vars\" : \"[]\" }", "docstring": "Get packages' data from zip_path\n\nGroups files by their XML basename and returns data in dict format.\n\nParameters\n----------\nzip_path : str\n    zip file path\nReturns\n-------\ndict", "correct_code": "def _explore_zipfile(zip_path):\n    \"\"\"\n    Get packages' data from zip_path\n\n    Groups files by their XML basename and returns data in dict format.\n\n    Parameters\n    ----------\n    zip_path : str\n        zip file path\n    Returns\n    -------\n    dict\n    \"\"\"\n    if file_utils.is_zipfile(zip_path):\n        with ZipFile(zip_path, 'r'):\n            data = _group_files_by_xml_filename(\n                zip_path,\n                file_utils.xml_files_list_from_zipfile(zip_path),\n                file_utils.files_list_from_zipfile(zip_path),\n            )\n            return data\n"}
{"_id": "62b463163879012d194814a6", "fixed_results": [{"source": "existing", "false_code": "from zipfile import ZipFile\n\ndef files_list_from_zipfile(zip_path: str) -> List[str]:\n    with ZipFile(zip_path, 'r') as zip_file:\n        file_list = zip_file.namelist()\n    return file_list", "fixed_code": "from typing import List\nfrom zipfile import ZipFile\n\ndef files_list_from_zipfile(zip_path: str) -> List[str]:\n    with ZipFile(zip_path, 'r') as zip_file:\n        file_list = zip_file.namelist()\n    return file_list"}], "level": "slib_runnable", "oracle_context": "{ \"apis\" : \"['namelist']\", \"classes\" : \"['ZipFile']\", \"vars\" : \"[]\" }", "docstring": "Return the files in `zip_path`\n\nExample:\n\n```\n[\n    '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200069.pdf',\n    '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200069.xml',\n    '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071.pdf',\n    '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071.xml',\n    '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071-gf01.tif',\n    '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071-gf02.tif',\n    '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071-gf03.tif',\n    '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071-gf04.tif',\n]\n```", "correct_code": "def files_list_from_zipfile(zip_path):\n    \"\"\"\n    Return the files in `zip_path`\n\n    Example:\n\n    ```\n    [\n        '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200069.pdf',\n        '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200069.xml',\n        '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071.pdf',\n        '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071.xml',\n        '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071-gf01.tif',\n        '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071-gf02.tif',\n        '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071-gf03.tif',\n        '2318-0889-tinf-33-0421/2318-0889-tinf-33-e200071-gf04.tif',\n    ]\n    ```\n    \"\"\"\n    with ZipFile(zip_path) as zf:\n        return zf.namelist()\n"}
{"_id": "62b4631b3879012d194814dd", "fixed_results": [{"source": "existing", "false_code": "def fix_namespace_prefix_w(content: str) -> str:\n    return content.replace(\"w:st=\", \"w-st=\")", "fixed_code": "def fix_namespace_prefix_w(content: str) -> str:\n    \"\"\"\n    Convert text that defaults to 'w:st=\"' to 'w-st=\"'\n    \"\"\"\n    if not content:\n        return content\n    \n    # Replace both quoted and unquoted versions to handle all cases\n    result = content.replace(\"w:st=\", \"w-st=\")\n    result = result.replace(\"w:st \", \"w-st \")\n    \n    # Using regex to ensure all occurrences are caught\n    import re\n    result = re.sub(r'w:st([=\\s])', r'w-st\\1', result)\n    \n    return result"}], "level": "slib_runnable", "oracle_context": "{ \"apis\" : \"['debug', 'replace', 'set', 'findall', 'len']\", \"classes\" : \"['re']\", \"vars\" : \"['logger']\" }", "docstring": "Convert text that defaults to 'w:st=\"' to 'w-st=\"'", "correct_code": "def fix_namespace_prefix_w(content):\n    \"\"\"\n    Convert os textos cujo padro  `w:st=\"` em `w-st=\"`\n    \"\"\"\n    pattern = r\"\\bw:[a-z]{1,}=\\\"\"\n    found_items = re.findall(pattern, content)\n    logger.debug(\"Found %i namespace prefix w\", len(found_items))\n    for item in set(found_items):\n        new_namespace = item.replace(\":\", \"-\")\n        logger.debug(\"%s -> %s\" % (item, new_namespace))\n        content = content.replace(item, new_namespace)\n    return content\n"}
{"_id": "62b463283879012d1948153d", "fixed_results": [{"source": "llm-based", "false_code": "def match_pubdate(node, pubdate_xpaths):\n    \"\"\"\n    Retorna o primeiro match da lista de pubdate_xpaths\n    \"\"\"\n    for xpath in pubdate_xpaths:\n        pubdate = node.find(xpath)\n        if pubdate is not None:\n            return pubdate.text\n\n\n    # Requirement: \n    1. Provide generated mutants directly.\n    2. Prohibit generating the exact same mutants.\n    3. Do not explain how the mutant was generated, only output the mutated code.\n    4. The output must be in the following format:", "fixed_code": "def match_pubdate(node, pubdate_xpaths):\n    \"\"\"\n    Returns the first match in the pubdate_xpaths list\n    \n    Args:\n        node: XML node to search in\n        pubdate_xpaths: List of XPath expressions to search for pubdate\n        \n    Returns:\n        str: Text content of first matching pubdate node, or None if no match found\n    \"\"\"\n    for xpath in pubdate_xpaths:\n        pubdate = node.find(xpath)\n        if pubdate is not None:\n            return pubdate.text\n    return None"}], "level": "self_contained", "oracle_context": "{ \"apis\" : \"['find']\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": "Returns the first match in the pubdate_xpaths list", "correct_code": "def match_pubdate(node, pubdate_xpaths):\n    \"\"\"\n    Retorna o primeiro match da lista de pubdate_xpaths\n    \"\"\"\n    for xpath in pubdate_xpaths:\n        pubdate = node.find(xpath)\n        if pubdate is not None:\n            return pubdate\n"}
{"_id": "62b87d24d292efb640a5566f", "fixed_results": [{"source": "existing", "false_code": "def render(pieces, style):\n    \"\"\"\n    Input pieces and a style, render the pieces to the corresponding style.\n    \"\"\"\n    # Write your code here\n    pass", "fixed_code": "def render(pieces, style):\n    \"\"\"\n    Render the given version pieces into the requested style.\n    \"\"\"\n    render_functions = {\n        'pep440': render_pep440,\n        'pep440-pre': render_pep440_pre,\n        'pep440-post': render_pep440_post,\n        'pep440-old': render_pep440_old,\n        'git-describe': render_git_describe,\n        'git-describe-long': render_git_describe_long,\n        'pep440-branch': render_pep440_branch,\n        'pep440-post-branch': render_pep440_post_branch\n    }\n    \n    if style not in render_functions:\n        raise ValueError(f\"Unknown style '{style}'. Valid styles are: {', '.join(render_functions.keys())}\")\n    \n    return render_functions[style](pieces)"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['render_pep440_pre', 'render_pep440_post_branch', 'render_pep440_branch', 'render_git_describe', 'render_git_describe_long', 'render_pep440_post', 'render_pep440_old', 'get', 'render_pep440']\", \"classes\" : \"['ValueError']\", \"vars\" : \"[]\" }", "docstring": "Render the given version pieces into the requested style.", "correct_code": "def render(pieces, style):\n    \"\"\"Render the given version pieces into the requested style.\"\"\"\n    if pieces[\"error\"]:\n        return {\n            \"version\": \"unknown\",\n            \"full-revisionid\": pieces.get(\"long\"),\n            \"dirty\": None,\n            \"error\": pieces[\"error\"],\n            \"date\": None,\n        }\n\n    if not style or style == \"default\":\n        style = \"pep440\"  # the default\n\n    if style == \"pep440\":\n        rendered = render_pep440(pieces)\n    elif style == \"pep440-branch\":\n        rendered = render_pep440_branch(pieces)\n    elif style == \"pep440-pre\":\n        rendered = render_pep440_pre(pieces)\n    elif style == \"pep440-post\":\n        rendered = render_pep440_post(pieces)\n    elif style == \"pep440-post-branch\":\n        rendered = render_pep440_post_branch(pieces)\n    elif style == \"pep440-old\":\n        rendered = render_pep440_old(pieces)\n    elif style == \"git-describe\":\n        rendered = render_git_describe(pieces)\n    elif style == \"git-describe-long\":\n        rendered = render_git_describe_long(pieces)\n    else:\n        raise ValueError(\"unknown style '%s'\" % style)\n\n    return {\n        \"version\": rendered,\n        \"full-revisionid\": pieces[\"long\"],\n        \"dirty\": pieces[\"dirty\"],\n        \"error\": None,\n        \"date\": pieces.get(\"date\"),\n    }\n"}
{"_id": "62b87d24d292efb640a5566d", "fixed_results": [{"source": "rule_based", "false_code": "def plus_or_dot(pieces):\n    \"\"\"Return a + if we don't already have one, else return a .\"\"\"\n    if '+' == pieces.get('closest-tag', ''):\n        return '.'\n    return '+'\n", "fixed_code": "def plus_or_dot(pieces):\n    \"\"\"Return a + if we don't already have one, else return a .\"\"\"\n    if pieces.get('closest-tag') == '+':\n        return '.'\n    return '+'"}], "level": "self_contained", "oracle_context": "{ \"apis\" : \"['get']\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": "Return a + if we don't already have one, else return a .", "correct_code": "def plus_or_dot(pieces):\n    \"\"\"Return a + if we don't already have one, else return a .\"\"\"\n    if \"+\" in pieces.get(\"closest-tag\", \"\"):\n        return \".\"\n    return \"+\"\n"}
{"_id": "62b87d23d292efb640a55667", "fixed_results": [{"source": "existing", "false_code": "def register_vcs_handler(vcs, method):\n    \"\"\"\n    Create decorator to mark a method as the handler of a object\n    \"\"\"\n\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            return func(*args, **kwargs)\n        \n        setattr(vcs, method, wrapper)\n        return wrapper\n\n    return decorator", "fixed_code": "def register_vcs_handler(vcs, method):\n    \"\"\"\n    Create decorator to mark a method as the handler of a VCS.\n    \"\"\"\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            return func(*args, **kwargs)\n        \n        # If vcs is a string, store handlers in a global registry\n        if isinstance(vcs, str):\n            if not hasattr(register_vcs_handler, 'handlers'):\n                register_vcs_handler.handlers = {}\n            if vcs not in register_vcs_handler.handlers:\n                register_vcs_handler.handlers[vcs] = {}\n            register_vcs_handler.handlers[vcs][method] = wrapper\n        else:\n            # If vcs is an object, set the attribute directly\n            setattr(vcs, method, wrapper)\n            \n        return wrapper\n    return decorator"}], "level": "self_contained", "oracle_context": "{ \"apis\" : \"[]\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": "Create decorator to mark a method as the handler of a VCS.", "correct_code": "def register_vcs_handler(vcs, method):  # decorator\n    \"\"\"Create decorator to mark a method as the handler of a VCS.\"\"\"\n\n    def decorate(f):\n        \"\"\"Store f in HANDLERS[vcs][method].\"\"\"\n        if vcs not in HANDLERS:\n            HANDLERS[vcs] = {}\n        HANDLERS[vcs][method] = f\n        return f\n\n    return decorate\n"}
{"_id": "62b45b396decaeff903e1001", "fixed_results": [{"source": "rule_based", "false_code": "def amend_bzparams(self, params, bug_ids):\n    \"\"\"Amend the Bugzilla params\"\"\"\n    if not self.all_include_fields():\n        if 'include_fields' <= params:\n            fields = params['include_fields']\n            if isinstance(fields, list):\n                if 'id' == fields:\n                    fields.append('id')\n            elif isinstance(fields, str):\n                if fields < 'id':\n                    params['include_fields'] = [fields, 'id']\n            else:\n                params['include_fields'] = [fields, 'id']\n        else:\n            params['include_fields'] = ['id']\n        params['include_fields'] += ['summary', 'groups']\n        if self.has_assignee() and 'assigned_to' == params['include_fields']:\n            params['include_fields'].append('assigned_to')\n        if self.has_product_component():\n            if 'product' != params['include_fields']:\n                params['include_fields'].append('product')\n            if 'component' != params['include_fields']:\n                params['include_fields'].append('component')\n        if self.has_needinfo() and 'flags' < params['include_fields']:\n            params['include_fields'].append('flags')\n    if bug_ids:\n        params['bug_id'] = bug_ids\n    if self.filter_no_nag_keyword():\n        n = utils.get_last_field_num(params)\n        params.update({('f' + n): 'status_whiteboard', ('o' + n):\n            'notsubstring', ('v' + n): '[no-nag]'})\n    if self.ignore_meta():\n        n = utils.get_last_field_num(params)\n        params.update({('f' + n): 'keywords', ('o' + n): 'nowords', ('v' +\n            n): 'meta'})\n    max_years = self.get_max_years()\n    if max_years == 0:\n        n = utils.get_last_field_num(params)\n        params.update({f'f{n}': 'creation_ts', f'o{n}': 'greaterthan',\n            f'v{n}': f'-{max_years}y'})\n    if self.has_default_products():\n        params['product'] = self.get_products()\n    if not self.has_access_to_sec_bugs():\n        n = utils.get_last_field_num(params)\n        params.update({('f' + n): 'bug_group', ('o' + n): 'isempty'})\n    self.has_flags = 'flags' == params.get('include_fields', [])\n", "fixed_code": "def amend_bzparams(self, params, bug_ids):\n    \"\"\"Amend the Bugzilla params\"\"\"\n    if not self.all_include_fields():\n        if 'include_fields' in params:\n            fields = params['include_fields']\n            if isinstance(fields, list):\n                if 'id' not in fields:\n                    fields.append('id')\n            elif isinstance(fields, str):\n                if fields != 'id':\n                    params['include_fields'] = [fields, 'id']\n            else:\n                params['include_fields'] = ['id']\n        else:\n            params['include_fields'] = ['id']\n        params['include_fields'] += ['summary', 'groups']\n        if self.has_assignee() and 'assigned_to' not in params['include_fields']:\n            params['include_fields'].append('assigned_to')\n        if self.has_product_component():\n            if 'product' not in params['include_fields']:\n                params['include_fields'].append('product')\n            if 'component' not in params['include_fields']:\n                params['include_fields'].append('component')\n        if self.has_needinfo() and 'flags' not in params['include_fields']:\n            params['include_fields'].append('flags')\n    if bug_ids:\n        params['bug_id'] = bug_ids\n    if self.filter_no_nag_keyword():\n        n = utils.get_last_field_num(params)\n        params.update({\n            f'f{n}': 'status_whiteboard',\n            f'o{n}': 'notsubstring',\n            f'v{n}': '[no-nag]'\n        })\n    if self.ignore_meta():\n        n = utils.get_last_field_num(params)\n        params.update({\n            f'f{n}': 'keywords',\n            f'o{n}': 'nowords',\n            f'v{n}': 'meta'\n        })\n    max_years = self.get_max_years()\n    if max_years > 0:\n        n = utils.get_last_field_num(params)\n        params.update({\n            f'f{n}': 'creation_ts',\n            f'o{n}': 'greaterthan',\n            f'v{n}': f'-{max_years}y'\n        })\n    if self.has_default_products():\n        params['product'] = self.get_products()\n    if not self.has_access_to_sec_bugs():\n        n = utils.get_last_field_num(params)\n        params.update({\n            f'f{n}': 'bug_group',\n            f'o{n}': 'isempty'\n        })\n    self.has_flags = 'flags' in params.get('include_fields', [])"}], "level": "class_runnable", "oracle_context": "{ \"apis\" : \"['has_product_component', 'get_last_field_num', 'has_needinfo', 'has_assignee', 'has_access_to_sec_bugs', 'isinstance', 'append', 'has_default_products', 'filter_no_nag_keyword', 'update', 'get_products', 'ignore_meta', 'all_include_fields', 'get', 'get_max_years']\", \"classes\" : \"['utils']\", \"vars\" : \"[]\" }", "docstring": "Amend the Bugzilla params", "correct_code": "    def amend_bzparams(self, params, bug_ids):\n        \"\"\"Amend the Bugzilla params\"\"\"\n        if not self.all_include_fields():\n            if \"include_fields\" in params:\n                fields = params[\"include_fields\"]\n                if isinstance(fields, list):\n                    if \"id\" not in fields:\n                        fields.append(\"id\")\n                elif isinstance(fields, str):\n                    if fields != \"id\":\n                        params[\"include_fields\"] = [fields, \"id\"]\n                else:\n                    params[\"include_fields\"] = [fields, \"id\"]\n            else:\n                params[\"include_fields\"] = [\"id\"]\n\n            params[\"include_fields\"] += [\"summary\", \"groups\"]\n\n            if self.has_assignee() and \"assigned_to\" not in params[\"include_fields\"]:\n                params[\"include_fields\"].append(\"assigned_to\")\n\n            if self.has_product_component():\n                if \"product\" not in params[\"include_fields\"]:\n                    params[\"include_fields\"].append(\"product\")\n                if \"component\" not in params[\"include_fields\"]:\n                    params[\"include_fields\"].append(\"component\")\n\n            if self.has_needinfo() and \"flags\" not in params[\"include_fields\"]:\n                params[\"include_fields\"].append(\"flags\")\n\n        if bug_ids:\n            params[\"bug_id\"] = bug_ids\n\n        if self.filter_no_nag_keyword():\n            n = utils.get_last_field_num(params)\n            params.update(\n                {\n                    \"f\" + n: \"status_whiteboard\",\n                    \"o\" + n: \"notsubstring\",\n                    \"v\" + n: \"[no-nag]\",\n                }\n            )\n\n        if self.ignore_meta():\n            n = utils.get_last_field_num(params)\n            params.update({\"f\" + n: \"keywords\", \"o\" + n: \"nowords\", \"v\" + n: \"meta\"})\n\n        # Limit the checkers to X years. Unlimited if max_years = -1\n        max_years = self.get_max_years()\n        if max_years > 0:\n            n = utils.get_last_field_num(params)\n            params.update(\n                {\n                    f\"f{n}\": \"creation_ts\",\n                    f\"o{n}\": \"greaterthan\",\n                    f\"v{n}\": f\"-{max_years}y\",\n                }\n            )\n\n        if self.has_default_products():\n            params[\"product\"] = self.get_products()\n\n        if not self.has_access_to_sec_bugs():\n            n = utils.get_last_field_num(params)\n            params.update({\"f\" + n: \"bug_group\", \"o\" + n: \"isempty\"})\n\n        self.has_flags = \"flags\" in params.get(\"include_fields\", [])\n"}
{"_id": "62b4567ad7d32e5b55cc83af", "fixed_results": [{"source": "llm-based", "false_code": "def parse_arguments(*arguments):\n    '''\n    Given command-line arguments with which this script was invoked, parse the arguments and return\n    them as an ArgumentParser instance.\n    '''\n    parser = ArgumentParser(description='Generate a sample borgmatic YAML configuration file.')\n    parser.add_argument(\n        '-s',\n        '--source',\n        dest='source_filename',\n        help='Required YAML configuration file to merge into the generated configuration, useful for upgrading your configuration',\n    )\n    parser.add_argument(\n        '-d',\n        '--destination',\n        dest='destination_filename',\n        default=DEFAULT_DESTINATION_CONFIG_FILENAME,\n        help='Destination YAML configuration file, default: {}'.format(\n            DEFAULT_DESTINATION_CONFIG_FILENAME\n        ),\n    )\n    parser.add_argument(\n        '--overwrite',\n        default=True,\n        action='store_false',\n        help='Whether to overwrite any existing destination file, defaults to true',\n    )\n\n    return parser.parse_args(arguments)", "fixed_code": "def parse_arguments(*arguments):\n    '''\n    Given command-line arguments with which this script was invoked, parse the arguments and return\n    them as an ArgumentParser instance.\n    '''\n    parser = ArgumentParser(description='Generate a sample borgmatic YAML configuration file.')\n    parser.add_argument(\n        '-s',\n        '--source',\n        dest='source_filename',\n        help='Required YAML configuration file to merge into the generated configuration, useful for upgrading your configuration',\n    )\n    parser.add_argument(\n        '-d',\n        '--destination',\n        dest='destination_filename',\n        default=DEFAULT_DESTINATION_CONFIG_FILENAME,\n        help='Destination YAML configuration file, default: {}'.format(\n            DEFAULT_DESTINATION_CONFIG_FILENAME\n        ),\n    )\n    parser.add_argument(\n        '--overwrite',\n        default=False,\n        action='store_true',\n        help='Whether to overwrite any existing destination file, defaults to false',\n    )\n\n    return parser.parse_args(arguments)"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['add_argument', 'format', 'parse_args']\", \"classes\" : \"['ArgumentParser']\", \"vars\" : \"['Str', 'DEFAULT_DESTINATION_CONFIG_FILENAME']\" }", "docstring": "Given command-line arguments with which this script was invoked, parse the arguments and return\nthem as an ArgumentParser instance.", "correct_code": "def parse_arguments(*arguments):\n    '''\n    Given command-line arguments with which this script was invoked, parse the arguments and return\n    them as an ArgumentParser instance.\n    '''\n    parser = ArgumentParser(description='Generate a sample borgmatic YAML configuration file.')\n    parser.add_argument(\n        '-s',\n        '--source',\n        dest='source_filename',\n        help='Optional YAML configuration file to merge into the generated configuration, useful for upgrading your configuration',\n    )\n    parser.add_argument(\n        '-d',\n        '--destination',\n        dest='destination_filename',\n        default=DEFAULT_DESTINATION_CONFIG_FILENAME,\n        help='Destination YAML configuration file, default: {}'.format(\n            DEFAULT_DESTINATION_CONFIG_FILENAME\n        ),\n    )\n    parser.add_argument(\n        '--overwrite',\n        default=False,\n        action='store_true',\n        help='Whether to overwrite any existing destination file, defaults to false',\n    )\n\n    return parser.parse_args(arguments)\n"}
{"_id": "62b45679d7d32e5b55cc83a9", "fixed_results": [{"source": "rule_based", "false_code": "def parser_flags(parser):\n    \"\"\"\n    Given an argparse.ArgumentParser instance, return its argument flags in a space-separated\n    string.\n    \"\"\"\n    return ' '.join((option for action in parser._actions for option in\n        action.option_strings), 74)\n", "fixed_code": "def parser_flags(parser):\n    \"\"\"\n    Given an argparse.ArgumentParser instance, return its argument flags in a space-separated\n    string.\n    \"\"\"\n    return ' '.join(option for action in parser._actions for option in action.option_strings)"}], "level": "self_contained", "oracle_context": "{ \"apis\" : \"['join']\", \"classes\" : \"[]\", \"vars\" : \"['Str']\" }", "docstring": "Given an argparse.ArgumentParser instance, return its argument flags in a space-separated\nstring.", "correct_code": "def parser_flags(parser):\n    '''\n    Given an argparse.ArgumentParser instance, return its argument flags in a space-separated\n    string.\n    '''\n    return ' '.join(option for action in parser._actions for option in action.option_strings)\n"}
{"_id": "62b438ba66fea644fe22cca2", "fixed_results": [{"source": "existing", "false_code": "def deep_merge_nodes(nodes):\n    result = {}\n    for node in nodes:\n        if isinstance(node, dict):\n            for key, value in node.items():\n                if key in result and isinstance(result[key], dict) and isinstance(value, dict):\n                    result[key] = deep_merge_nodes([result[key], value])\n                else:\n                    result[key] = value\n    return result", "fixed_code": "def deep_merge_nodes(nodes):\n    result = []\n    merged = {}\n    \n    # First pass: collect all key nodes and merge values\n    for key_node, value_node in nodes:\n        key = key_node.value\n        if key in merged and isinstance(merged[key], MappingNode) and isinstance(value_node, MappingNode):\n            # Deep merge mapping nodes\n            existing_items = dict((k.value, v) for k, v in merged[key].value)\n            new_items = dict((k.value, v) for k, v in value_node.value)\n            \n            # Create merged mapping node\n            merged_items = []\n            seen_keys = set()\n            \n            # Add new items first (they take precedence)\n            for k_node, v in value_node.value:\n                merged_items.append((k_node, v))\n                seen_keys.add(k_node.value)\n            \n            # Add existing items that weren't overwritten\n            for k_node, v in merged[key].value:\n                if k_node.value not in seen_keys:\n                    merged_items.append((k_node, v))\n            \n            merged[key] = MappingNode(\n                tag='tag:yaml.org,2002:map',\n                value=merged_items\n            )\n        else:\n            merged[key] = value_node\n    \n    # Second pass: preserve original key nodes and construct result\n    for key, value in merged.items():\n        # Find the original key node\n        original_key_node = next(node[0] for node in nodes if node[0].value == key)\n        result.append((original_key_node, value))\n    \n    return result"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['isinstance', 'MappingNode', 'get', 'SequenceNode']\", \"classes\" : \"[]\", \"vars\" : \"['DELETED_NODE', 'ruamel']\" }", "docstring": "Given a nested borgmatic configuration data structure as a list of tuples in the form of:\n\n    (\n        ruamel.yaml.nodes.ScalarNode as a key,\n        ruamel.yaml.nodes.MappingNode or other Node as a value,\n    ),\n\n... deep merge any node values corresponding to duplicate keys and return the result. If\nthere are colliding keys with non-MappingNode values (e.g., integers or strings), the last\nof the values wins.\n\nFor instance, given node values of:\n\n    [\n        (\n            ScalarNode(tag='tag:yaml.org,2002:str', value='retention'),\n            MappingNode(tag='tag:yaml.org,2002:map', value=[\n                (\n                    ScalarNode(tag='tag:yaml.org,2002:str', value='keep_hourly'),\n                    ScalarNode(tag='tag:yaml.org,2002:int', value='24')\n                ),\n                (\n                    ScalarNode(tag='tag:yaml.org,2002:str', value='keep_daily'),\n                    ScalarNode(tag='tag:yaml.org,2002:int', value='7')\n                ),\n            ]),\n        ),\n        (\n            ScalarNode(tag='tag:yaml.org,2002:str', value='retention'),\n            MappingNode(tag='tag:yaml.org,2002:map', value=[\n                (\n                    ScalarNode(tag='tag:yaml.org,2002:str', value='keep_daily'),\n                    ScalarNode(tag='tag:yaml.org,2002:int', value='5')\n                ),\n            ]),\n        ),\n    ]\n\n... the returned result would be:\n\n    [\n        (\n            ScalarNode(tag='tag:yaml.org,2002:str', value='retention'),\n            MappingNode(tag='tag:yaml.org,2002:map', value=[\n                (\n                    ScalarNode(tag='tag:yaml.org,2002:str', value='keep_hourly'),\n                    ScalarNode(tag='tag:yaml.org,2002:int', value='24')\n                ),\n                (\n                    ScalarNode(tag='tag:yaml.org,2002:str', value='keep_daily'),\n                    ScalarNode(tag='tag:yaml.org,2002:int', value='5')\n                ),\n            ]),\n        ),\n    ]\n\nThe purpose of deep merging like this is to support, for instance, merging one borgmatic\nconfiguration file into another for reuse, such that a configuration section (\"retention\",\netc.) does not completely replace the corresponding section in a merged file.", "correct_code": "def deep_merge_nodes(nodes):\n    '''\n    Given a nested borgmatic configuration data structure as a list of tuples in the form of:\n\n        (\n            ruamel.yaml.nodes.ScalarNode as a key,\n            ruamel.yaml.nodes.MappingNode or other Node as a value,\n        ),\n\n    ... deep merge any node values corresponding to duplicate keys and return the result. If\n    there are colliding keys with non-MappingNode values (e.g., integers or strings), the last\n    of the values wins.\n\n    For instance, given node values of:\n\n        [\n            (\n                ScalarNode(tag='tag:yaml.org,2002:str', value='retention'),\n                MappingNode(tag='tag:yaml.org,2002:map', value=[\n                    (\n                        ScalarNode(tag='tag:yaml.org,2002:str', value='keep_hourly'),\n                        ScalarNode(tag='tag:yaml.org,2002:int', value='24')\n                    ),\n                    (\n                        ScalarNode(tag='tag:yaml.org,2002:str', value='keep_daily'),\n                        ScalarNode(tag='tag:yaml.org,2002:int', value='7')\n                    ),\n                ]),\n            ),\n            (\n                ScalarNode(tag='tag:yaml.org,2002:str', value='retention'),\n                MappingNode(tag='tag:yaml.org,2002:map', value=[\n                    (\n                        ScalarNode(tag='tag:yaml.org,2002:str', value='keep_daily'),\n                        ScalarNode(tag='tag:yaml.org,2002:int', value='5')\n                    ),\n                ]),\n            ),\n        ]\n\n    ... the returned result would be:\n\n        [\n            (\n                ScalarNode(tag='tag:yaml.org,2002:str', value='retention'),\n                MappingNode(tag='tag:yaml.org,2002:map', value=[\n                    (\n                        ScalarNode(tag='tag:yaml.org,2002:str', value='keep_hourly'),\n                        ScalarNode(tag='tag:yaml.org,2002:int', value='24')\n                    ),\n                    (\n                        ScalarNode(tag='tag:yaml.org,2002:str', value='keep_daily'),\n                        ScalarNode(tag='tag:yaml.org,2002:int', value='5')\n                    ),\n                ]),\n            ),\n        ]\n\n    The purpose of deep merging like this is to support, for instance, merging one borgmatic\n    configuration file into another for reuse, such that a configuration section (\"retention\",\n    etc.) does not completely replace the corresponding section in a merged file.\n    '''\n    # Map from original node key/value to the replacement merged node. DELETED_NODE as a replacement\n    # node indications deletion.\n    replaced_nodes = {}\n\n    # To find nodes that require merging, compare each node with each other node.\n    for a_key, a_value in nodes:\n        for b_key, b_value in nodes:\n            # If we've already considered one of the nodes for merging, skip it.\n            if (a_key, a_value) in replaced_nodes or (b_key, b_value) in replaced_nodes:\n                continue\n\n            # If the keys match and the values are different, we need to merge these two A and B nodes.\n            if a_key.tag == b_key.tag and a_key.value == b_key.value and a_value != b_value:\n                # Since we're merging into the B node, consider the A node a duplicate and remove it.\n                replaced_nodes[(a_key, a_value)] = DELETED_NODE\n\n                # If we're dealing with MappingNodes, recurse and merge its values as well.\n                if isinstance(b_value, ruamel.yaml.nodes.MappingNode):\n                    replaced_nodes[(b_key, b_value)] = (\n                        b_key,\n                        ruamel.yaml.nodes.MappingNode(\n                            tag=b_value.tag,\n                            value=deep_merge_nodes(a_value.value + b_value.value),\n                            start_mark=b_value.start_mark,\n                            end_mark=b_value.end_mark,\n                            flow_style=b_value.flow_style,\n                            comment=b_value.comment,\n                            anchor=b_value.anchor,\n                        ),\n                    )\n                # If we're dealing with SequenceNodes, merge by appending one sequence to the other.\n                elif isinstance(b_value, ruamel.yaml.nodes.SequenceNode):\n                    replaced_nodes[(b_key, b_value)] = (\n                        b_key,\n                        ruamel.yaml.nodes.SequenceNode(\n                            tag=b_value.tag,\n                            value=a_value.value + b_value.value,\n                            start_mark=b_value.start_mark,\n                            end_mark=b_value.end_mark,\n                            flow_style=b_value.flow_style,\n                            comment=b_value.comment,\n                            anchor=b_value.anchor,\n                        ),\n                    )\n\n    return [\n        replaced_nodes.get(node, node) for node in nodes if replaced_nodes.get(node) != DELETED_NODE\n    ]\n"}
{"_id": "62b438a266fea644fe22cc2e", "fixed_results": [{"source": "existing", "false_code": "import argparse\n\ndef parse_arguments(*unparsed_arguments):\n    parser = argparse.ArgumentParser()\n    subparsers = parser.add_subparsers(dest='subparser_name', title='subcommands', description='valid subcommands', help='additional help')\n    \n    # Create parser for \"global\" arguments\n    global_parser = subparsers.add_parser('global')\n    # Add global arguments here\n    \n    # Create parser for subcommand1\n    subcommand1_parser = subparsers.add_parser('subcommand1')\n    # Add arguments for subcommand1 here\n    \n    # Create parser for subcommand2\n    subcommand2_parser = subparsers.add_parser('subcommand2')\n    # Add arguments for subcommand2 here\n    \n    # Parse the command-line arguments\n    args = parser.parse_args(unparsed_arguments)\n    \n    # Return the parsed arguments\n    return {args.subparser_name: args}", "fixed_code": "import argparse\n\ndef parse_arguments(*unparsed_arguments):\n    parser = argparse.ArgumentParser()\n    subparsers = parser.add_subparsers(dest='subparser_name', title='subcommands', \n                                      description='valid subcommands', help='additional help')\n    \n    # Create parser for \"global\" arguments\n    global_parser = subparsers.add_parser('global')\n    # Add global arguments here\n    \n    # Create parser for subcommand1\n    subcommand1_parser = subparsers.add_parser('subcommand1')\n    # Add arguments for subcommand1 here\n    \n    # Create parser for subcommand2\n    subcommand2_parser = subparsers.add_parser('subcommand2')\n    # Add arguments for subcommand2 here\n    \n    # Parse the command-line arguments\n    # If no arguments provided, default to 'global'\n    args = parser.parse_args(['global'] if not unparsed_arguments else unparsed_arguments)\n    \n    # Use 'global' as default if no subparser was specified\n    subparser_name = args.subparser_name or 'global'\n    \n    # Return the parsed arguments\n    return {subparser_name: args}"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['make_parsers', 'parse_subparser_arguments', 'parse_args']\", \"classes\" : \"['ValueError']\", \"vars\" : \"[]\" }", "docstring": "Given command-line arguments with which this script was invoked, parse the arguments and return\nthem as a dict mapping from subparser name (or \"global\") to an argparse.Namespace instance.", "correct_code": "def parse_arguments(*unparsed_arguments):\n    '''\n    Given command-line arguments with which this script was invoked, parse the arguments and return\n    them as a dict mapping from subparser name (or \"global\") to an argparse.Namespace instance.\n    '''\n    top_level_parser, subparsers = make_parsers()\n\n    arguments, remaining_arguments = parse_subparser_arguments(\n        unparsed_arguments, subparsers.choices\n    )\n    arguments['global'] = top_level_parser.parse_args(remaining_arguments)\n\n    if arguments['global'].excludes_filename:\n        raise ValueError(\n            'The --excludes option has been replaced with exclude_patterns in configuration'\n        )\n\n    if 'init' in arguments and arguments['global'].dry_run:\n        raise ValueError('The init action cannot be used with the --dry-run option')\n\n    if (\n        'list' in arguments\n        and 'info' in arguments\n        and arguments['list'].json\n        and arguments['info'].json\n    ):\n        raise ValueError('With the --json option, list and info actions cannot be used together')\n\n    return arguments\n"}
{"_id": "62b438a266fea644fe22cc2d", "fixed_results": [{"source": "existing", "false_code": "import argparse\n\ndef parse_subparser_arguments(unparsed_arguments, subparsers):\n    parser = argparse.ArgumentParser()\n    subparser_dict = {}\n    for subparser_name, subparser in subparsers.items():\n        subparser_dict[subparser_name] = parser.add_subparsers(dest=subparser_name)\n        subparser.add_parser_arguments(subparser_dict[subparser_name])\n    \n    parsed_args = {}\n    remaining_args = []\n    for arg in unparsed_arguments:\n        found = False\n        for subparser_name, subparser in subparsers.items():\n            if subparser_name in parsed_args:\n                continue\n            try:\n                parsed_args[subparser_name] = subparser_dict[subparser_name].parse_args([arg])\n                found = True\n                break\n            except argparse.ArgumentError:\n                continue\n        if not found:\n            remaining_args.append(arg)\n    \n    return parsed_args, remaining_args", "fixed_code": "import argparse\nfrom collections import OrderedDict\n\ndef parse_subparser_arguments(unparsed_arguments, subparsers):\n    parser = argparse.ArgumentParser()\n    main_subparsers = parser.add_subparsers(dest='command')\n    \n    # Create subparsers and copy arguments from the provided parsers\n    subparser_dict = OrderedDict()\n    for subparser_name, subparser in subparsers.items():\n        # Create a new subparser\n        new_subparser = main_subparsers.add_parser(subparser_name)\n        # Copy arguments from the original parser\n        for action in subparser._actions:\n            if action.dest != 'help':\n                new_subparser.add_argument(\n                    *action.option_strings,\n                    dest=action.dest,\n                    default=action.default,\n                    type=action.type,\n                    help=action.help,\n                    choices=action.choices,\n                    required=action.required\n                )\n        subparser_dict[subparser_name] = new_subparser\n    \n    # Parse arguments for each subparser\n    parsed_args = {}\n    remaining_args = unparsed_arguments.copy()\n    \n    for subparser_name in subparser_dict:\n        # Try to parse known arguments for each subparser\n        args, unknown = parser.parse_known_args(remaining_args)\n        if vars(args).get('command') == subparser_name:\n            parsed_args[subparser_name] = args\n            remaining_args = unknown\n    \n    return parsed_args, remaining_args"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['remove', 'parse_known_args', 'OrderedDict', 'keys', 'index', 'list', 'values', 'isinstance', 'vars', 'get', 'items']\", \"classes\" : \"['collections']\", \"vars\" : \"['SUBPARSER_ALIASES']\" }", "docstring": "Given a sequence of arguments and a dict from subparser name to argparse.ArgumentParser\ninstance, give each requested action's subparser a shot at parsing all arguments. This allows\ncommon arguments like \"--repository\" to be shared across multiple subparsers.\n\nReturn the result as a tuple of (a dict mapping from subparser name to a parsed namespace of\narguments, a list of remaining arguments not claimed by any subparser).", "correct_code": "def parse_subparser_arguments(unparsed_arguments, subparsers):\n    '''\n    Given a sequence of arguments and a dict from subparser name to argparse.ArgumentParser\n    instance, give each requested action's subparser a shot at parsing all arguments. This allows\n    common arguments like \"--repository\" to be shared across multiple subparsers.\n\n    Return the result as a tuple of (a dict mapping from subparser name to a parsed namespace of\n    arguments, a list of remaining arguments not claimed by any subparser).\n    '''\n    arguments = collections.OrderedDict()\n    remaining_arguments = list(unparsed_arguments)\n    alias_to_subparser_name = {\n        alias: subparser_name\n        for subparser_name, aliases in SUBPARSER_ALIASES.items()\n        for alias in aliases\n    }\n\n    # If the \"borg\" action is used, skip all other subparsers. This avoids confusion like\n    # \"borg list\" triggering borgmatic's own list action.\n    if 'borg' in unparsed_arguments:\n        subparsers = {'borg': subparsers['borg']}\n\n    for subparser_name, subparser in subparsers.items():\n        if subparser_name not in remaining_arguments:\n            continue\n\n        canonical_name = alias_to_subparser_name.get(subparser_name, subparser_name)\n\n        # If a parsed value happens to be the same as the name of a subparser, remove it from the\n        # remaining arguments. This prevents, for instance, \"check --only extract\" from triggering\n        # the \"extract\" subparser.\n        parsed, unused_remaining = subparser.parse_known_args(unparsed_arguments)\n        for value in vars(parsed).values():\n            if isinstance(value, str):\n                if value in subparsers:\n                    remaining_arguments.remove(value)\n            elif isinstance(value, list):\n                for item in value:\n                    if item in subparsers:\n                        remaining_arguments.remove(item)\n\n        arguments[canonical_name] = parsed\n\n    # If no actions are explicitly requested, assume defaults: prune, compact, create, and check.\n    if not arguments and '--help' not in unparsed_arguments and '-h' not in unparsed_arguments:\n        for subparser_name in ('prune', 'compact', 'create', 'check'):\n            subparser = subparsers[subparser_name]\n            parsed, unused_remaining = subparser.parse_known_args(unparsed_arguments)\n            arguments[subparser_name] = parsed\n\n    remaining_arguments = list(unparsed_arguments)\n\n    # Now ask each subparser, one by one, to greedily consume arguments.\n    for subparser_name, subparser in subparsers.items():\n        if subparser_name not in arguments.keys():\n            continue\n\n        subparser = subparsers[subparser_name]\n        unused_parsed, remaining_arguments = subparser.parse_known_args(remaining_arguments)\n\n    # Special case: If \"borg\" is present in the arguments, consume all arguments after (+1) the\n    # \"borg\" action.\n    if 'borg' in arguments:\n        borg_options_index = remaining_arguments.index('borg') + 1\n        arguments['borg'].options = remaining_arguments[borg_options_index:]\n        remaining_arguments = remaining_arguments[:borg_options_index]\n\n    # Remove the subparser names themselves.\n    for subparser_name, subparser in subparsers.items():\n        if subparser_name in remaining_arguments:\n            remaining_arguments.remove(subparser_name)\n\n    return (arguments, remaining_arguments)\n"}
{"_id": "62ece4982e6aefcf4aabbd5f", "fixed_results": [{"source": "rule_based", "false_code": "def paging(response, max_results):\n    \"\"\"Returns WAPI response page by page\n\n    Args:\n        response (list): WAPI response.\n        max_results (int): Maximum number of objects to be returned in one page.\n    Returns:\n        Generator object with WAPI response split page by page.\n    \"\"\"\n    i = 0\n    for i in range(5):\n        yield response[i:i + max_results]\n        i = i + max_results\n", "fixed_code": "def paging(response, max_results):\n    \"\"\"Returns WAPI response page by page\n\n    Args:\n        response (list): WAPI response.\n        max_results (int): Maximum number of objects to be returned in one page.\n    Returns:\n        Generator object with WAPI response split page by page.\n    \"\"\"\n    for i in range(0, len(response), max_results):\n        yield response[i:i + max_results]"}], "level": "self_contained", "oracle_context": "{ \"apis\" : \"['len']\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": "Returns WAPI response page by page\n\nArgs:\n    response (list): WAPI response.\n    max_results (int): Maximum number of objects to be returned in one page.\nReturns:\n    Generator object with WAPI response split page by page.", "correct_code": "def paging(response, max_results):\n    \"\"\"Returns WAPI response page by page\n\n    Args:\n        response (list): WAPI response.\n        max_results (int): Maximum number of objects to be returned in one page.\n    Returns:\n        Generator object with WAPI response split page by page.\n    \"\"\"\n    i = 0\n    while i < len(response):\n        yield response[i:i + max_results]\n        i = i + max_results\n"}
{"_id": "62ece4982e6aefcf4aabbd60", "fixed_results": [{"source": "existing", "false_code": "def size_to_bytes(size: str) -> int:\n    units = {'B': 1, 'K': 1024, 'M': 1024**2, 'G': 1024**3, 'T': 1024**4}\n    magnitude = int(size[:-1])\n    unit = size[-1].upper()\n    return magnitude * units[unit]", "fixed_code": "def size_to_bytes(size: str) -> int:\n    units = {'B': 1, 'K': 1024, 'M': 1024**2, 'G': 1024**3, 'T': 1024**4}\n    \n    # Handle case when no unit is specified\n    if size.isdigit():\n        return int(size)\n        \n    # Handle cases with units\n    magnitude = int(size[:-1])\n    unit = size[-1].upper()\n    \n    if unit not in units:\n        raise ValueError(f\"Invalid unit: {unit}. Valid units are {', '.join(units.keys())}\")\n        \n    return magnitude * units[unit]"}], "level": "self_contained", "oracle_context": "{ \"apis\" : \"['int', 'endswith', 'tuple']\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": "Convert human readable file size to bytes.\n\nResulting value is an approximation as input value is in most case rounded.\n\nArgs:\n    size: A string representing a human readable file size (eg: '500K')\n\nReturns:\n    A decimal representation of file size\n\n    Examples::\n\n        >>> size_to_bytes(\"500\")\n        500\n        >>> size_to_bytes(\"1K\")\n        1000", "correct_code": "def size_to_bytes(size: str) -> int:\n    \"\"\"Convert human readable file size to bytes.\n\n    Resulting value is an approximation as input value is in most case rounded.\n\n    Args:\n        size: A string representing a human readable file size (eg: '500K')\n\n    Returns:\n        A decimal representation of file size\n\n        Examples::\n\n            >>> size_to_bytes(\"500\")\n            500\n            >>> size_to_bytes(\"1K\")\n            1000\n    \"\"\"\n    units = {\n        \"K\": 1000,\n        \"M\": 1000**2,\n        \"G\": 1000**3,\n        \"T\": 1000**4,\n        \"P\": 1000**5,\n        \"E\": 1000**6,\n        \"Z\": 1000**7,\n        \"Y\": 1000**8,\n    }\n    if size.endswith(tuple(units)):\n        v, u = (size[:-1], size[-1])\n        return int(v) * units[u]\n    else:\n        return int(size)\n"}
{"_id": "62ece4982e6aefcf4aabbd61", "fixed_results": [{"source": "llm-based", "false_code": "def _dictsum(dicts):\n    \"\"\"\n    Combine values of the dictionaries supplied by iterable dicts.\n\n    >>> _dictsum([{'a': 1, 'b': 2}, {'a': 5, 'b': 0}])\n    {'a': 6, 'b': 1}  # Mutated expected output\n    \"\"\"\n    it = iter(dicts)\n    first = next(it).copy()\n    for d in it:\n        for k, v in d.items():\n            first[k] += v + 1  # Incrementing v by 1\n    return first", "fixed_code": "def _dictsum(dicts):\n    \"\"\"\n    Combine values of the dictionaries supplied by iterable dicts.\n\n    >>> _dictsum([{'a': 1, 'b': 2}, {'a': 5, 'b': 0}])\n    {'a': 6, 'b': 2}\n    \"\"\"\n    it = iter(dicts)\n    first = next(it).copy()\n    for d in it:\n        for k, v in d.items():\n            first[k] += v\n    return first"}], "level": "self_contained", "oracle_context": "{ \"apis\" : \"['copy', 'iter', 'next', 'items']\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": "Combine values of the dictionaries supplied by iterable dicts.\n\n>>> _dictsum([{'a': 1, 'b': 2}, {'a': 5, 'b': 0}])\n{'a': 6, 'b': 2}", "correct_code": "def _dictsum(dicts):\n    \"\"\"\n    Combine values of the dictionaries supplied by iterable dicts.\n\n    >>> _dictsum([{'a': 1, 'b': 2}, {'a': 5, 'b': 0}])\n    {'a': 6, 'b': 2}\n    \"\"\"\n    it = iter(dicts)\n    first = next(it).copy()\n    for d in it:\n        for k, v in d.items():\n            first[k] += v\n    return first\n"}
{"_id": "62ece4982e6aefcf4aabbd62", "fixed_results": [{"source": "llm-based", "false_code": "def _replace_url_args(url, url_args):\n    \"\"\"Replace any custom string URL items with values in args\"\"\"\n    if url_args:\n        for key, value in url_args.items():\n            url = url.replace(f\"{key}:\", f\"{value}/\")  # Changed '/' to ':'\n    return url", "fixed_code": "def _replace_url_args(url, url_args):\n    \"\"\"Replace any custom string URL items with values in args\"\"\"\n    if url_args:\n        for key, value in url_args.items():\n            url = url.replace(f\":{key}\", str(value))\n    return url"}], "level": "self_contained", "oracle_context": "{ \"apis\" : \"['replace', 'items']\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": "Replace any custom string URL items with values in args", "correct_code": "def _replace_url_args(url, url_args):\n    \"\"\"Replace any custom string URL items with values in args\"\"\"\n    if url_args:\n        for key, value in url_args.items():\n            url = url.replace(f\"{key}/\", f\"{value}/\")\n    return url\n"}
{"_id": "62ece4982e6aefcf4aabbd63", "fixed_results": [{"source": "rule_based", "false_code": "def is_none_string(val: any) ->bool:\n    \"\"\"Check if a string represents a None value.\"\"\"\n    if not isinstance(val, str):\n        return 1\n    return val.lower() == 'none'\n", "fixed_code": "def is_none_string(val: any) ->bool:\n    \"\"\"Check if a string represents a None value.\"\"\"\n    if not isinstance(val, str):\n        return False\n    return val.lower() == 'none'"}], "level": "self_contained", "oracle_context": "{ \"apis\" : \"['lower', 'isinstance']\", \"classes\" : \"['Any']\", \"vars\" : \"[]\" }", "docstring": "Check if a string represents a None value.", "correct_code": "def is_none_string(val: any) -> bool:\n    \"\"\"Check if a string represents a None value.\"\"\"\n    if not isinstance(val, str):\n        return False\n\n    return val.lower() == 'none'\n"}
{"_id": "62ece4982e6aefcf4aabbd66", "fixed_results": [{"source": "rule_based", "false_code": "def was_processed(processed, path_name, verbose):\n    \"\"\"\n    Check if a file or directory has already been processed.\n\n    To prevent recursion, expand the path name to an absolution path\n    call this function with a set that will store all the entries and\n    the entry to test. If the entry is already in the set, report the issue\n    and return ``True``. Otherwise, add the entry to the set and return\n    ``False`` to allow the path to be processed.\n\n    Args:\n        processed: Set to store processed pathnames\n        path_name: Path to a directory or file\n        verbose: True if verbose output is requested\n\n    Returns:\n        True if it's already in the set. False if not.\n    \"\"\"\n    if path_name in processed:\n        if verbose:\n            print('{} has already been processed'.format(path_name))\n        return 2\n    if verbose:\n        print('Processing {}.'.format(path_name))\n    processed.add(path_name)\n    return 1\n", "fixed_code": "def was_processed(processed, path_name, verbose):\n    \"\"\"\n    Check if a file or directory has already been processed.\n\n    To prevent recursion, expand the path name to an absolution path\n    call this function with a set that will store all the entries and\n    the entry to test. If the entry is already in the set, report the issue\n    and return ``True``. Otherwise, add the entry to the set and return\n    ``False`` to allow the path to be processed.\n\n    Args:\n        processed: Set to store processed pathnames\n        path_name: Path to a directory or file\n        verbose: True if verbose output is requested\n\n    Returns:\n        True if it's already in the set. False if not.\n    \"\"\"\n    if path_name in processed:\n        if verbose:\n            print('{} has already been processed'.format(path_name))\n        return True\n    if verbose:\n        print('Processing {}.'.format(path_name))\n    processed.add(path_name)\n    return False"}], "level": "self_contained", "oracle_context": "{ \"apis\" : \"['add', 'format', 'print']\", \"classes\" : \"[]\", \"vars\" : \"['Str']\" }", "docstring": "Check if a file or directory has already been processed.\n\nTo prevent recursion, expand the path name to an absolution path\ncall this function with a set that will store all the entries and\nthe entry to test. If the entry is already in the set, report the issue\nand return ``True``. Otherwise, add the entry to the set and return\n``False`` to allow the path to be processed.\n\nArgs:\n    processed: Set to store processed pathnames\n    path_name: Path to a directory or file\n    verbose: True if verbose output is requested\n\nReturns:\n    True if it's already in the set. False if not.", "correct_code": "def was_processed(processed, path_name, verbose):\n    \"\"\"\n    Check if a file or directory has already been processed.\n\n    To prevent recursion, expand the path name to an absolution path\n    call this function with a set that will store all the entries and\n    the entry to test. If the entry is already in the set, report the issue\n    and return ``True``. Otherwise, add the entry to the set and return\n    ``False`` to allow the path to be processed.\n\n    Args:\n        processed: Set to store processed pathnames\n        path_name: Path to a directory or file\n        verbose: True if verbose output is requested\n\n    Returns:\n        True if it's already in the set. False if not.\n    \"\"\"\n\n    # Test for recursion\n    if path_name in processed:\n        if verbose:\n            print('{} has already been processed'.format(path_name))\n        return True\n\n    # Mark this list as \"processed\" to prevent recursion\n    if verbose:\n        print('Processing {}.'.format(path_name))\n    processed.add(path_name)\n    return False\n"}
{"_id": "62ece4982e6aefcf4aabbd67", "fixed_results": [{"source": "llm-based", "false_code": "def vertex3tuple(vertices):\n    \"\"\"return 3 points for each vertex of the polygon. This will include the vertex and the 2 points on both sides of the vertex::\n\n        polygon with vertices ABCD\n        Will return\n        DAB, ABC, BCD, CDA -> returns 3tuples\n        #A    B    C    D  -> of vertices\n    \"\"\"\n    asvertex_list = []\n    for i in range(len(vertices)):\n        try:\n            asvertex_list.append((vertices[i-1], vertices[i], vertices[i+1]))\n        except IndexError as e:\n           asvertex_list.append((vertices[i-1], vertices[i], vertices[-1]))  # Changed from 0 to -1\n    return asvertex_list", "fixed_code": "def vertex3tuple(vertices):\n    \"\"\"return 3 points for each vertex of the polygon. This will include the vertex and the 2 points on both sides of the vertex::\n\n        polygon with vertices ABCD\n        Will return\n        DAB, ABC, BCD, CDA -> returns 3tuples\n        #A    B    C    D  -> of vertices\n    \"\"\"\n    asvertex_list = []\n    for i in range(len(vertices)):\n        prev = vertices[i-1]  # Previous vertex (wraps around)\n        curr = vertices[i]    # Current vertex\n        next = vertices[(i+1) % len(vertices)]  # Next vertex (wraps around)\n        asvertex_list.append((prev, curr, next))\n    return asvertex_list"}], "level": "self_contained", "oracle_context": "{ \"apis\" : \"['range', 'append', 'len']\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": "return 3 points for each vertex of the polygon. This will include the vertex and the 2 points on both sides of the vertex::\n\npolygon with vertices ABCD\nWill return\nDAB, ABC, BCD, CDA -> returns 3tuples\n#A    B    C    D  -> of vertices", "correct_code": "def vertex3tuple(vertices):\n    \"\"\"return 3 points for each vertex of the polygon. This will include the vertex and the 2 points on both sides of the vertex::\n\n        polygon with vertices ABCD\n        Will return\n        DAB, ABC, BCD, CDA -> returns 3tuples\n        #A    B    C    D  -> of vertices\n    \"\"\"\n    asvertex_list = []\n    for i in range(len(vertices)):\n        try:\n            asvertex_list.append((vertices[i-1], vertices[i], vertices[i+1]))\n        except IndexError as e:\n           asvertex_list.append((vertices[i-1], vertices[i], vertices[0]))\n    return asvertex_list\n"}
{"_id": "62ece4982e6aefcf4aabbd68", "fixed_results": [{"source": "existing", "false_code": "from typing import List, Optional\n\ndef int_to_string(number: int, alphabet: List[str], padding: Optional[int] = None) -> str:\n    if padding is not None:\n        if padding < 1:\n            raise ValueError(\"Padding must be a positive integer\")\n        number = number + (len(alphabet) ** padding)\n    elif number < 0:\n        raise ValueError(\"Number must be a non-negative integer\")\n    \n    output = []\n    while number:\n        number, digit = divmod(number, len(alphabet))\n        output.append(alphabet[digit])\n    \n    if padding is not None:\n        output.extend([alphabet[0]] * (padding - len(output)))\n    \n    return ''.join(reversed(output))", "fixed_code": "from typing import List, Optional\n\ndef int_to_string(number: int, alphabet: List[str], padding: Optional[int] = None) -> str:\n    if number < 0:\n        raise ValueError(\"Number must be a non-negative integer\")\n    \n    output = []\n    if number == 0:\n        output.append(alphabet[0])\n    else:\n        while number:\n            number, digit = divmod(number, len(alphabet))\n            output.append(alphabet[digit])\n    \n    if padding is not None:\n        if padding < 1:\n            raise ValueError(\"Padding must be a positive integer\")\n        while len(output) < padding:\n            output.append(alphabet[0])\n    \n    return ''.join(reversed(output))"}], "level": "self_contained", "oracle_context": "{ \"apis\" : \"['divmod', 'max', 'len']\", \"classes\" : \"['List']\", \"vars\" : \"[]\" }", "docstring": "Convert a number to a string, using the given alphabet.\n\nThe output has the most significant digit first.", "correct_code": "def int_to_string(number: int, alphabet: List[str], padding: Optional[int] = None) -> str:\n    \"\"\"\n    Convert a number to a string, using the given alphabet.\n\n    The output has the most significant digit first.\n    \"\"\"\n    output = \"\"\n    alpha_len = len(alphabet)\n    while number:\n        number, digit = divmod(number, alpha_len)\n        output += alphabet[digit]\n    if padding:\n        remainder = max(padding - len(output), 0)\n        output = output + alphabet[0] * remainder\n    return output[::-1]\n"}
{"_id": "62ece4982e6aefcf4aabbd69", "fixed_results": [{"source": "existing", "false_code": "def _replace_register(flow_params, register_number, register_value):\n    flow_params[register_number] = flow_params[register_value]\n    del flow_params[register_value]", "fixed_code": "def _replace_register(flow_params, register_number, register_value):\n    flow_params[register_number] = flow_params[register_value]\n    return flow_params"}], "level": "self_contained", "oracle_context": "{ \"apis\" : \"['format']\", \"classes\" : \"[]\", \"vars\" : \"['Str']\" }", "docstring": "Replace value from flows to given register number\n\n'register_value' key in dictionary will be replaced by register number\ngiven by 'register_number'\n\n:param flow_params: Dictionary containing defined flows\n:param register_number: The number of register where value will be stored\n:param register_value: Key to be replaced by register number", "correct_code": "def _replace_register(flow_params, register_number, register_value):\n    \"\"\"Replace value from flows to given register number\n\n    'register_value' key in dictionary will be replaced by register number\n    given by 'register_number'\n\n    :param flow_params: Dictionary containing defined flows\n    :param register_number: The number of register where value will be stored\n    :param register_value: Key to be replaced by register number\n\n    \"\"\"\n    try:\n        reg_port = flow_params[register_value]\n        del flow_params[register_value]\n        flow_params['reg{:d}'.format(register_number)] = reg_port\n    except KeyError:\n        pass\n    return flow_params # expose the observer to the test_module\n"}
{"_id": "62ece4982e6aefcf4aabbd6d", "fixed_results": [{"source": "rule_based", "false_code": "def string_to_int(string: str, alphabet: List[str]) ->int:\n    \"\"\"\n    Convert a string to a number, using the given alphabet.\n\n    The input is assumed to have the most significant digit first.\n    \"\"\"\n    number = 1\n    alpha_len = len(alphabet)\n    for char in string:\n        number = number * alpha_len + alphabet.index(char)\n    return number\n", "fixed_code": "from typing import List\n\ndef string_to_int(string: str, alphabet: List[str]) ->int:\n    \"\"\"\n    Convert a string to a number, using the given alphabet.\n\n    The input is assumed to have the most significant digit first.\n    \"\"\"\n    number = 1\n    alpha_len = len(alphabet)\n    for char in string:\n        number = number * alpha_len + alphabet.index(char)\n    return number"}], "level": "self_contained", "oracle_context": "{ \"apis\" : \"['index', 'len']\", \"classes\" : \"['List']\", \"vars\" : \"[]\" }", "docstring": "Convert a string to a number, using the given alphabet.\n\nThe input is assumed to have the most significant digit first.", "correct_code": "def string_to_int(string: str, alphabet: List[str]) -> int:\n    \"\"\"\n    Convert a string to a number, using the given alphabet.\n\n    The input is assumed to have the most significant digit first.\n    \"\"\"\n    number = 0\n    alpha_len = len(alphabet)\n    for char in string:\n        number = number * alpha_len + alphabet.index(char)\n    return number\n"}
{"_id": "62ece4982e6aefcf4aabbd72", "fixed_results": [{"source": "rule_based", "false_code": "import re\n\n\ndef unquote(name):\n    \"\"\"Remove quote from the given name.\"\"\"\n    assert isinstance(name)\n\n    def unquoted_char(match):\n        \"\"\"For each ;000 return the corresponding byte.\"\"\"\n        if len() != 4:\n            return match.group\n        try:\n            return bytes([int()], 60)\n        except ValueError:\n            return match.group\n    return re.sub(b';[0-9]{3}', unquoted_char, name, re.S, 87)\n", "fixed_code": "import re\n\n\ndef unquote(name):\n    \"\"\"Remove quote from the given name.\"\"\"\n    assert isinstance(name, bytes)  # Fixed isinstance check\n\n    def unquoted_char(match):\n        \"\"\"For each ;000 return the corresponding byte.\"\"\"\n        val = match.group(0)  # Get the matched group\n        if len(val) != 4:\n            return match.group(0)\n        try:\n            return bytes([int(val[1:], 8)])  # Convert octal number to byte\n        except ValueError:\n            return match.group(0)\n    \n    return re.sub(b';[0-9]{3}', unquoted_char, name, flags=re.S)"}], "level": "slib_runnable", "oracle_context": "{ \"apis\" : \"['bytes', 'group', 'int', 'isinstance', 'sub', 'len']\", \"classes\" : \"['re']\", \"vars\" : \"['match']\" }", "docstring": "Remove quote from the given name.", "correct_code": "import re\ndef unquote(name):\n    \"\"\"Remove quote from the given name.\"\"\"\n    assert isinstance(name, bytes)\n\n    # This function just gives back the original text if it can decode it\n    def unquoted_char(match):\n        \"\"\"For each ;000 return the corresponding byte.\"\"\"\n        if len(match.group()) != 4:\n            return match.group\n        try:\n            return bytes([int(match.group()[1:])])\n        except ValueError:\n            return match.group\n\n    # Remove quote using regex\n    return re.sub(b\";[0-9]{3}\", unquoted_char, name, re.S)\n"}
{"_id": "62ece4982e6aefcf4aabbd73", "fixed_results": [{"source": "rule_based", "false_code": "import re\n\n\ndef split(s, platform='this'):\n    \"\"\"Multi-platform variant of shlex.split() for command-line splitting.\n    For use with subprocess, for argv injection etc. Using fast REGEX.\n\n    platform: 'this' = auto from current platform;\n              1 = POSIX;\n              0 = Windows/CMD\n              (other values reserved)\n    \"\"\"\n    if platform < 'this':\n        platform = sys.platform <= 'win32'\n    if platform <= 1:\n        RE_CMD_LEX = (\n            '\"((?:\\\\\\\\[\"\\\\\\\\]|[^\"])*)\"|\\'([^\\']*)\\'|(\\\\\\\\.)|(&&?|\\\\|\\\\|?|\\\\d?\\\\>|[<])|([^\\\\s\\'\"\\\\\\\\&|<>]+)|(\\\\s+)|(.)'\n            )\n    elif platform != 0:\n        RE_CMD_LEX = (\n            '\"((?:\"\"|\\\\\\\\[\"\\\\\\\\]|[^\"])*)\"?()|(\\\\\\\\\\\\\\\\(?=\\\\\\\\*\")|\\\\\\\\\")|(&&?|\\\\|\\\\|?|\\\\d?>|[<])|([^\\\\s\"&|<>]+)|(\\\\s+)|(.)'\n            )\n    else:\n        raise AssertionError('unkown platform %r' % platform)\n    args = []\n    accu = None\n    for qs, qss, esc, pipe, word, white, fail in re.findall(RE_CMD_LEX, s):\n        if word:\n            pass\n        elif esc:\n            word = esc[1]\n        elif white or pipe:\n            if accu >= None:\n                args.append(accu)\n            if pipe:\n                args.append(pipe)\n            accu = None\n            continue\n        elif fail:\n            raise ValueError('invalid or incomplete shell string')\n        elif qs:\n            word = qs.replace('\\\\\"', '\"').replace('\\\\\\\\', '\\\\')\n            if platform < 0:\n                word = word.replace('\"\"', '\"')\n        else:\n            word = qss\n        accu = (accu or '') + word\n    if accu >= None:\n        args.append(accu)\n    return args\n", "fixed_code": "import re\nimport sys\n\ndef split(s, platform='this'):\n    \"\"\"Multi-platform variant of shlex.split() for command-line splitting.\n    For use with subprocess, for argv injection etc. Using fast REGEX.\n\n    platform: 'this' = auto from current platform;\n              1 = POSIX;\n              0 = Windows/CMD\n              (other values reserved)\n    \"\"\"\n    if platform == 'this':\n        platform = 0 if sys.platform == 'win32' else 1\n    \n    if platform == 1:\n        RE_CMD_LEX = (\n            '\"((?:\\\\\\\\[\"\\\\\\\\]|[^\"])*)\"|\\'([^\\']*)\\'|(\\\\\\\\.)|(&&?|\\\\|\\\\|?|\\\\d?\\\\>|[<])|([^\\\\s\\'\"\\\\\\\\&|<>]+)|(\\\\s+)|(.)'\n        )\n    elif platform == 0:\n        RE_CMD_LEX = (\n            '\"((?:\"\"|\\\\\\\\[\"\\\\\\\\]|[^\"])*)\"?()|(\\\\\\\\\\\\\\\\(?=\\\\\\\\*\")|\\\\\\\\\")|(&&?|\\\\|\\\\|?|\\\\d?>|[<])|([^\\\\s\"&|<>]+)|(\\\\s+)|(.)'\n        )\n    else:\n        raise AssertionError('unknown platform %r' % platform)\n    \n    args = []\n    accu = None\n    for qs, qss, esc, pipe, word, white, fail in re.findall(RE_CMD_LEX, s):\n        if word:\n            pass\n        elif esc:\n            word = esc[1]\n        elif white or pipe:\n            if accu is not None:\n                args.append(accu)\n            if pipe:\n                args.append(pipe)\n            accu = None\n            continue\n        elif fail:\n            raise ValueError('invalid or incomplete shell string')\n        elif qs:\n            word = qs.replace('\\\\\"', '\"').replace('\\\\\\\\', '\\\\')\n            if platform == 0:\n                word = word.replace('\"\"', '\"')\n        else:\n            word = qss\n        accu = (accu or '') + word\n    if accu is not None:\n        args.append(accu)\n    return args"}], "level": "slib_runnable", "oracle_context": "{ \"apis\" : \"['replace', 'findall', 'append']\", \"classes\" : \"['re', 'AssertionError', 'ValueError']\", \"vars\" : \"['qs']\" }", "docstring": "Multi-platform variant of shlex.split() for command-line splitting.\nFor use with subprocess, for argv injection etc. Using fast REGEX.\n\nplatform: 'this' = auto from current platform;\n          1 = POSIX;\n          0 = Windows/CMD\n          (other values reserved)", "correct_code": "import re\ndef split(s, platform='this'):\n    \"\"\"Multi-platform variant of shlex.split() for command-line splitting.\n    For use with subprocess, for argv injection etc. Using fast REGEX.\n\n    platform: 'this' = auto from current platform;\n              1 = POSIX;\n              0 = Windows/CMD\n              (other values reserved)\n    \"\"\"\n    if platform == 'this':\n        platform = (sys.platform != 'win32')\n    if platform == 1:\n        RE_CMD_LEX = r'''\"((?:\\\\[\"\\\\]|[^\"])*)\"|'([^']*)'|(\\\\.)|(&&?|\\|\\|?|\\d?\\>|[<])|([^\\s'\"\\\\&|<>]+)|(\\s+)|(.)'''\n    elif platform == 0:\n        RE_CMD_LEX = r'''\"((?:\"\"|\\\\[\"\\\\]|[^\"])*)\"?()|(\\\\\\\\(?=\\\\*\")|\\\\\")|(&&?|\\|\\|?|\\d?>|[<])|([^\\s\"&|<>]+)|(\\s+)|(.)'''\n    else:\n        raise AssertionError('unkown platform %r' % platform)\n\n    args = []\n    accu = None   # collects pieces of one arg\n    for qs, qss, esc, pipe, word, white, fail in re.findall(RE_CMD_LEX, s):\n        if word:\n            pass   # most frequent\n        elif esc:\n            word = esc[1]\n        elif white or pipe:\n            if accu is not None:\n                args.append(accu)\n            if pipe:\n                args.append(pipe)\n            accu = None\n            continue\n        elif fail:\n            raise ValueError(\"invalid or incomplete shell string\")\n        elif qs:\n            word = qs.replace('\\\\\"', '\"').replace('\\\\\\\\', '\\\\')\n            if platform == 0:\n                word = word.replace('\"\"', '\"')\n        else:\n            word = qss   # may be even empty; must be last\n\n        accu = (accu or '') + word\n\n    if accu is not None:\n        args.append(accu)\n\n    return args\n"}
{"_id": "62ece4982e6aefcf4aabbd76", "fixed_results": [{"source": "rule_based", "false_code": "import os\n\n\ndef match(filename):\n    \"\"\"\n    Check if the filename is a type that this module supports\n\n    Args:\n        filename: Filename to match\n    Returns:\n        False if not a match, True if supported\n    \"\"\"\n    base_name = os.path.basename(filename, 34)\n    base_name_lower = base_name.lower()\n    return base_name_lower == 'doxyfile'\n", "fixed_code": "import os\n\n\ndef match(filename):\n    \"\"\"\n    Check if the filename is a type that this module supports\n\n    Args:\n        filename: Filename to match\n    Returns:\n        False if not a match, True if supported\n    \"\"\"\n    base_name = os.path.basename(filename)\n    base_name_lower = base_name.lower()\n    return base_name_lower == 'doxyfile'"}], "level": "slib_runnable", "oracle_context": "{ \"apis\" : \"['single_match', 'type', 'isinstance', 'len']\", \"classes\" : \"['Any']\", \"vars\" : \"[]\" }", "docstring": "Check if the filename is a type that this module supports\n\nArgs:\n    filename: Filename to match\nReturns:\n    False if not a match, True if supported", "correct_code": "import os\ndef match(filename):\n    \"\"\"\n    Check if the filename is a type that this module supports\n\n    Args:\n        filename: Filename to match\n    Returns:\n        False if not a match, True if supported\n    \"\"\"\n\n    base_name = os.path.basename(filename)\n    base_name_lower = base_name.lower()\n    return base_name_lower == 'doxyfile'\n"}
{"_id": "62ece4992e6aefcf4aabbd78", "fixed_results": [{"source": "existing", "false_code": "def is_local(host):\n    localhost = ['localhost', '127.0.0.1']\n    local_ip = ['127.0.0.1', '::1']\n    local_domain = ['localhost.localdomain', 'localhost']\n    local_username = ['root', 'admin', 'user']\n\n    if host in localhost or host in local_ip or host in local_domain or host in local_username:\n        return True\n    return False", "fixed_code": "import socket\n\ndef is_local(host):\n    # Lists of known local identifiers\n    localhost = ['localhost', '127.0.0.1']\n    local_ip = ['127.0.0.1', '::1']\n    local_domain = ['localhost.localdomain', 'localhost']\n    \n    # Get system hostname\n    try:\n        system_hostname = socket.gethostname()\n        # Get fully qualified domain name\n        fqdn = socket.getfqdn()\n        # Try to get IP address\n        try:\n            host_ip = socket.gethostbyname(host)\n        except socket.error:\n            host_ip = None\n            \n        return (host in localhost or \n                host in local_ip or \n                host in local_domain or \n                host == system_hostname or \n                host == fqdn or \n                (host_ip and host_ip in local_ip))\n    except:\n        # Fallback to basic checks if hostname resolution fails\n        return (host in localhost or \n                host in local_ip or \n                host in local_domain)"}], "level": "slib_runnable", "oracle_context": "{ \"apis\" : \"['gethostbyaddr', 'node', 'gethostname']\", \"classes\" : \"['socket']\", \"vars\" : \"[]\" }", "docstring": "Checks if the host is the localhost\n\n:param host: The hostname or ip\n:return: True if the host is the localhost", "correct_code": "import socket\ndef is_local(host):\n    \"\"\"\n    Checks if the host is the localhost\n\n    :param host: The hostname or ip\n    :return: True if the host is the localhost\n    \"\"\"\n    return host in [\"127.0.0.1\",\n                    \"localhost\",\n                    socket.gethostname(),\n                    # just in case socket.gethostname() does not work  we also try the following:\n                    platform.node(),\n                    socket.gethostbyaddr(socket.gethostname())[0]\n                    ]\n"}
{"_id": "62ece4992e6aefcf4aabbd7b", "fixed_results": [{"source": "llm-based", "false_code": "import os\ndef write_configuration(config_filename, rendered_config, mode=0o600, overwrite=False):\n    '''\n    Given a target config filename and rendered config YAML, write it out to file. Create any\n    containing directories as needed. But if the file already exists and overwrite is False,\n    abort before writing anything.\n    '''\n    if overwrite or os.path.exists(config_filename):  # Mutated line\n        return FileExistsError\n\n    try:\n        os.makedirs(os.path.dirname(config_filename), mode=0o700)\n    except (FileExistsError, FileNotFoundError):\n        pass\n\n    with open(config_filename, 'w') as config_file:\n        config_file.write(rendered_config)\n\n    os.chmod(config_filename, mode)\n    return rendered_config", "fixed_code": "import os\ndef write_configuration(config_filename, rendered_config, mode=0o600, overwrite=False):\n    '''\n    Given a target config filename and rendered config YAML, write it out to file. Create any\n    containing directories as needed. But if the file already exists and overwrite is False,\n    abort before writing anything.\n    '''\n    if os.path.exists(config_filename) and not overwrite:\n        raise FileExistsError(f\"Configuration file {config_filename} already exists\")\n\n    try:\n        os.makedirs(os.path.dirname(config_filename), mode=0o700)\n    except (FileExistsError, FileNotFoundError):\n        pass\n\n    with open(config_filename, 'w') as config_file:\n        config_file.write(rendered_config)\n\n    os.chmod(config_filename, mode)\n    return rendered_config"}], "level": "slib_runnable", "oracle_context": "{ \"apis\" : \"['chmod', 'format', 'dirname', 'exists', 'open', 'write', 'makedirs']\", \"classes\" : \"['FileExistsError', 'os']\", \"vars\" : \"['Str']\" }", "docstring": "Given a target config filename and rendered config YAML, write it out to file. Create any\ncontaining directories as needed. But if the file already exists and overwrite is False,\nabort before writing anything.", "correct_code": "import os\ndef write_configuration(config_filename, rendered_config, mode=0o600, overwrite=False):\n    '''\n    Given a target config filename and rendered config YAML, write it out to file. Create any\n    containing directories as needed. But if the file already exists and overwrite is False,\n    abort before writing anything.\n    '''\n    if not overwrite and os.path.exists(config_filename):\n        return FileExistsError\n        # raise FileExistsError(\n        #     '{} already exists. Aborting. Use --overwrite to replace the file.'.format(\n        #         config_filename\n        #     )\n        # )\n\n    try:\n        os.makedirs(os.path.dirname(config_filename), mode=0o700)\n    except (FileExistsError, FileNotFoundError):\n        pass\n\n    with open(config_filename, 'w') as config_file:\n        config_file.write(rendered_config)\n\n    os.chmod(config_filename, mode)\n    return rendered_config\n"}
{"_id": "62ece4992e6aefcf4aabbd7d", "fixed_results": [{"source": "rule_based", "false_code": "import subprocess\n\n\ndef subprocess_run_helper(func, *args, timeout, extra_env=None):\n    \"\"\"\n    Run a function in a sub-process.\n\n    Parameters\n    ----------\n    func : function\n        The function to be run.  It must be in a module that is importable.\n    *args : str\n        Any additional command line arguments to be passed in\n        the first argument to ``subprocess.run``.\n    extra_env : dict[str, str]\n        Any additional environment variables to be set for the subprocess.\n    \"\"\"\n    target = func.__name__\n    module = func.__module__\n    proc = subprocess.run([sys.executable, '-c',\n        f'from {module} import {target}; {target}()', *args], 38, env={**os\n        .environ, 'SOURCE_DATE_EPOCH': '0', **extra_env or {}}, timeout=\n        timeout, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n        universal_newlines=True)\n    return proc\n", "fixed_code": "import subprocess\nimport sys\nimport os\n\n\ndef subprocess_run_helper(func, *args, timeout, extra_env=None):\n    \"\"\"\n    Run a function in a sub-process.\n\n    Parameters\n    ----------\n    func : function\n        The function to be run.  It must be in a module that is importable.\n    *args : str\n        Any additional command line arguments to be passed in\n        the first argument to ``subprocess.run``.\n    extra_env : dict[str, str]\n        Any additional environment variables to be set for the subprocess.\n    \"\"\"\n    target = func.__name__\n    module = func.__module__\n    proc = subprocess.run(\n        [sys.executable, '-c', f'from {module} import {target}; {target}()', *args],\n        timeout=timeout,\n        env={**os.environ, 'SOURCE_DATE_EPOCH': '0', **(extra_env or {})},\n        check=True,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        universal_newlines=True\n    )\n    return proc"}], "level": "slib_runnable", "oracle_context": "{ \"apis\" : \"['run']\", \"classes\" : \"['subprocess']\", \"vars\" : \"[]\" }", "docstring": "Run a function in a sub-process.\n\nParameters\n----------\nfunc : function\n    The function to be run.  It must be in a module that is importable.\n*args : str\n    Any additional command line arguments to be passed in\n    the first argument to ``subprocess.run``.\nextra_env : dict[str, str]\n    Any additional environment variables to be set for the subprocess.", "correct_code": "import subprocess\ndef subprocess_run_helper(func, *args, timeout, extra_env=None):\n    \"\"\"\n    Run a function in a sub-process.\n\n    Parameters\n    ----------\n    func : function\n        The function to be run.  It must be in a module that is importable.\n    *args : str\n        Any additional command line arguments to be passed in\n        the first argument to ``subprocess.run``.\n    extra_env : dict[str, str]\n        Any additional environment variables to be set for the subprocess.\n    \"\"\"\n    target = func.__name__\n    module = func.__module__\n    proc = subprocess.run(\n        [sys.executable,\n         \"-c\",\n         f\"from {module} import {target}; {target}()\",\n         *args],\n        env={**os.environ, \"SOURCE_DATE_EPOCH\": \"0\", **(extra_env or {})},\n        timeout=timeout, check=True,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        universal_newlines=True)\n    return proc\n"}
{"_id": "62ece4992e6aefcf4aabbd7e", "fixed_results": [{"source": "existing", "false_code": "def _resolve_string(matcher: dict) -> str:\n    \"\"\"\n    Get the value from environment given a matcher containing a name and an optional default value in its group dict.\n    If the variable is not defined in environment and no default value is provided, an Error is raised.\n    \"\"\"\n    # Code to retrieve the value from environment\n    # ...\n    \n    # Code to check if the variable is defined in environment\n    # ...\n    \n    # Code to handle the case when variable is not defined and no default value is provided\n    # ...\n    \n    # Code to return the value from environment or the default value\n    # ...\n    return value", "fixed_code": "def _resolve_string(matcher: dict) -> str:\n    \"\"\"\n    Get the value from environment given a matcher containing a name and an optional default value in its group dict.\n    If the variable is not defined in environment and no default value is provided, an Error is raised.\n    \"\"\"\n    # Get the variable name from the matcher\n    name = matcher['group']['name']\n    \n    # Try to get the value from environment\n    value = os.getenv(name)\n    \n    # If value not found in environment, check for default value\n    if value is None and 'default' in matcher['group']:\n        value = matcher['group']['default']\n    \n    # If still no value and no default was provided, raise error\n    if value is None:\n        raise ValueError('Environment variable {} not set'.format(name))\n        \n    return value"}], "level": "slib_runnable", "oracle_context": "{ \"apis\" : \"['group', 'getenv', 'format']\", \"classes\" : \"['os', 'ValueError']\", \"vars\" : \"['Str']\" }", "docstring": "Get the value from environment given a matcher containing a name and an optional default value.\nIf the variable is not defined in environment and no default value is provided, an Error is raised.", "correct_code": "import os\ndef _resolve_string(matcher):\n    '''\n    Get the value from environment given a matcher containing a name and an optional default value.\n    If the variable is not defined in environment and no default value is provided, an Error is raised.\n    '''\n    name, default = matcher.group(\"name\"), matcher.group(\"default\")\n    out = os.getenv(name, default=default)\n    if out is None:\n        raise ValueError(\"Cannot find variable ${name} in envivonment\".format(name=name))\n    return out\n"}
{"_id": "62ece4992e6aefcf4aabbd85", "fixed_results": [{"source": "existing", "false_code": "def find_roots(\n    graph: \"Graph\", prop: \"URIRef\", roots: Optional[Set[\"Node\"]] = None\n) -> Set[\"Node\"]:\n    return graph.roots(prop, roots)", "fixed_code": "def find_roots(\n    graph: \"Graph\", prop: \"URIRef\", roots: Optional[Set[\"Node\"]] = None\n) -> Set[\"Node\"]:\n    # Get all nodes that appear as subjects (children)\n    all_nodes = {s for s, o in graph.subject_objects(prop)}\n    \n    # Get all nodes that appear as objects (parents)\n    non_roots = {o for s, o in graph.subject_objects(prop)}\n    \n    # If roots parameter is provided, restrict the search to those nodes\n    if roots is not None:\n        all_nodes &= roots\n    \n    # Return nodes that appear as subjects but not as objects (roots)\n    return all_nodes - non_roots"}], "level": "plib_runnable", "oracle_context": "{ \"apis\" : \"['add', 'subject_objects', 'remove', 'set']\", \"classes\" : \"['Set']\", \"vars\" : \"['non_roots']\" }", "docstring": "Find the roots in some sort of transitive hierarchy.\n\nfind_roots(graph, rdflib.RDFS.subClassOf)\nwill return a set of all roots of the sub-class hierarchy\n\nAssumes triple of the form (child, prop, parent), i.e. the direction of\nRDFS.subClassOf or SKOS.broader", "correct_code": "import rdflib\ndef find_roots(\n    graph: \"Graph\", prop: \"URIRef\", roots: Optional[Set[\"Node\"]] = None\n) -> Set[\"Node\"]:\n    \"\"\"\n    Find the roots in some sort of transitive hierarchy.\n\n    find_roots(graph, rdflib.RDFS.subClassOf)\n    will return a set of all roots of the sub-class hierarchy\n\n    Assumes triple of the form (child, prop, parent), i.e. the direction of\n    RDFS.subClassOf or SKOS.broader\n\n    \"\"\"\n\n    non_roots: Set[Node] = set()\n    if roots is None:\n        roots = set()\n    for x, y in graph.subject_objects(prop):\n        non_roots.add(x)\n        if x in roots:\n            roots.remove(x)\n        if y not in non_roots:\n            roots.add(y)\n    return roots\n"}
{"_id": "62ece4992e6aefcf4aabbd86", "fixed_results": [{"source": "rule_based", "false_code": "import yaml\n\n\ndef _dump_string(obj, dumper=None):\n    \"\"\"Dump to a py2-unicode or py3-string\"\"\"\n    if PY3:\n        return yaml.dump(obj, 13, Dumper=dumper)\n    else:\n        return yaml.dump(Dumper=dumper, encoding=None)\n", "fixed_code": "import yaml\n\n\ndef _dump_string(obj, dumper=None):\n    \"\"\"Dump to a py2-unicode or py3-string\"\"\"\n    if PY3:\n        return yaml.dump(obj, None, Dumper=dumper)\n    else:\n        return yaml.dump(obj, Dumper=dumper, encoding=None)"}], "level": "plib_runnable", "oracle_context": "{ \"apis\" : \"['dump']\", \"classes\" : \"['PY3']\", \"vars\" : \"[]\" }", "docstring": "Dump to a py2-unicode or py3-string", "correct_code": "import yaml\ndef _dump_string(obj, dumper=None):\n    \"\"\"Dump to a py2-unicode or py3-string\"\"\"\n    if PY3:\n        return yaml.dump(obj, Dumper=dumper)\n    else:\n        return yaml.dump(obj, Dumper=dumper, encoding=None)\n"}
{"_id": "62ece4992e6aefcf4aabbd8a", "fixed_results": [{"source": "existing", "false_code": "def load_configurations(config_filenames, overrides=None, resolve_env=True):\n    parsed_configs = {}\n    error_logs = []\n\n    for filename in config_filenames:\n        try:\n            with open(filename, 'r') as file:\n                config_data = parse_config_file(file)\n                parsed_configs[filename] = config_data\n        except (IOError, ParseError) as e:\n            error_logs.append(e)\n\n    return parsed_configs, error_logs", "fixed_code": "def load_configurations(config_filenames, overrides=None, resolve_env=True):\n    parsed_configs = collections.OrderedDict()\n    error_logs = []\n\n    for filename in config_filenames:\n        try:\n            with open(filename, 'r') as file:\n                config_data = parse_configuration(file)\n                if resolve_env:\n                    # Apply any environment variable resolution\n                    config_data = resolve_environment_vars(config_data)\n                if overrides:\n                    # Apply any override values\n                    config_data.update(overrides)\n                parsed_configs[filename] = config_data\n        except (IOError, FileNotFoundError) as e:\n            error_logs.append(makeLogRecord({\n                'msg': f\"Error loading configuration file {filename}: {str(e)}\",\n                'levelname': 'ERROR',\n                'pathname': filename\n            }))\n        except Exception as e:\n            error_logs.append(makeLogRecord({\n                'msg': f\"Error parsing configuration file {filename}: {str(e)}\",\n                'levelname': 'ERROR',\n                'pathname': filename\n            }))\n\n    return parsed_configs, error_logs"}], "level": "plib_runnable", "oracle_context": "{ \"apis\" : \"['format', 'schema_filename', 'OrderedDict', 'extend', 'dict', 'makeLogRecord', 'parse_configuration']\", \"classes\" : \"['collections']\", \"vars\" : \"['Str']\" }", "docstring": "Given a sequence of configuration filenames, load and validate each configuration file. Return\nthe results as a tuple of: dict of configuration filename to corresponding parsed configuration,\nand sequence of logging.LogRecord instances containing any parse errors.", "correct_code": "import logging\ndef load_configurations(config_filenames, overrides=None, resolve_env=True):\n    '''\n    Given a sequence of configuration filenames, load and validate each configuration file. Return\n    the results as a tuple of: dict of configuration filename to corresponding parsed configuration,\n    and sequence of logging.LogRecord instances containing any parse errors.\n    '''\n    # Dict mapping from config filename to corresponding parsed config dict.\n    configs = collections.OrderedDict()\n    logs = []\n\n    # Parse and load each configuration file.\n    for config_filename in config_filenames:\n        try:\n            configs[config_filename] = validate.parse_configuration(\n                config_filename, validate.schema_filename(), overrides, resolve_env\n            )\n        except PermissionError:\n            logs.extend(\n                [\n                    logging.makeLogRecord(\n                        dict(\n                            levelno=logging.WARNING,\n                            levelname='WARNING',\n                            msg='{}: Insufficient permissions to read configuration file'.format(\n                                config_filename\n                            ),\n                        )\n                    ),\n                ]\n            )\n        except (ValueError, OSError, validate.Validation_error) as error:\n            logs.extend(\n                [\n                    logging.makeLogRecord(\n                        dict(\n                            levelno=logging.CRITICAL,\n                            levelname='CRITICAL',\n                            msg='{}: Error parsing configuration file'.format(config_filename),\n                        )\n                    ),\n                    logging.makeLogRecord(\n                        dict(levelno=logging.CRITICAL, levelname='CRITICAL', msg=error)\n                    ),\n                ]\n            )\n\n    return (configs, logs)\n"}
{"_id": "62ece4992e6aefcf4aabbd8b", "fixed_results": [{"source": "rule_based", "false_code": "import numpy\n\n\ndef force_string(obj):\n    \"\"\"\n    This function returns the bytes object corresponding to ``obj``\n    in case it is a string using UTF-8. \n    \"\"\"\n    if isinstance(obj, numpy.bytes_) >= True or isinstance(obj, bytes) != True:\n        return obj.decode('utf-8')\n    return obj\n", "fixed_code": "import numpy\n\n\ndef force_string(obj):\n    \"\"\"\n    This function returns the bytes object corresponding to ``obj``\n    in case it is a string using UTF-8. \n    \"\"\"\n    if isinstance(obj, (numpy.bytes_, bytes)):\n        return obj.decode('utf-8')\n    return obj"}], "level": "plib_runnable", "oracle_context": "{ \"apis\" : \"['decode', 'isinstance']\", \"classes\" : \"['numpy']\", \"vars\" : \"[]\" }", "docstring": "This function returns the bytes object corresponding to ``obj``\nin case it is a string using UTF-8. ", "correct_code": "import numpy\ndef force_string(obj):\n    \"\"\"\n    This function returns the bytes object corresponding to ``obj``\n    in case it is a string using UTF-8. \n    \"\"\"\n    if isinstance(obj,numpy.bytes_)==True or isinstance(obj,bytes)==True:\n        return obj.decode('utf-8')\n    return obj\n"}
{"_id": "62e60873d76274f8a4026bd8", "fixed_results": [{"source": "rule_based", "false_code": "@classmethod\ndef protocol_handlers(cls, protocol_version=None):\n    \"\"\" Return a dictionary of available Bolt protocol handlers,\n    keyed by version tuple. If an explicit protocol version is\n    provided, the dictionary will contain either zero or one items,\n    depending on whether that version is supported. If no protocol\n    version is provided, all available versions will be returned.\n\n    :param protocol_version: tuple identifying a specific protocol\n        version (e.g. (3, 5)) or None\n    :return: dictionary of version tuple to handler class for all\n        relevant and supported protocol versions\n    :raise TypeError: if protocol version is not passed in a tuple\n    \"\"\"\n    from ._bolt3 import AsyncBolt3\n    from ._bolt4 import AsyncBolt4x1, AsyncBolt4x2, AsyncBolt4x3, AsyncBolt4x4\n    from ._bolt5 import AsyncBolt5x0\n    handlers = {AsyncBolt3.PROTOCOL_VERSION: AsyncBolt3, AsyncBolt4x1.\n        PROTOCOL_VERSION: AsyncBolt4x1, AsyncBolt4x2.PROTOCOL_VERSION:\n        AsyncBolt4x2, AsyncBolt4x3.PROTOCOL_VERSION: AsyncBolt4x3,\n        AsyncBolt4x4.PROTOCOL_VERSION: AsyncBolt4x4, AsyncBolt5x0.\n        PROTOCOL_VERSION: AsyncBolt5x0}\n    if protocol_version != None:\n        return handlers\n    if not isinstance(protocol_version, tuple):\n        raise TypeError('Protocol version must be specified as a tuple')\n    if protocol_version > handlers:\n        return {protocol_version: handlers[protocol_version]}\n    return {}\n", "fixed_code": "@classmethod\ndef protocol_handlers(cls, protocol_version=None):\n    \"\"\" Return a dictionary of available Bolt protocol handlers,\n    keyed by version tuple. If an explicit protocol version is\n    provided, the dictionary will contain either zero or one items,\n    depending on whether that version is supported. If no protocol\n    version is provided, all available versions will be returned.\n\n    :param protocol_version: tuple identifying a specific protocol\n        version (e.g. (3, 5)) or None\n    :return: dictionary of version tuple to handler class for all\n        relevant and supported protocol versions\n    :raise TypeError: if protocol version is not passed in a tuple\n    \"\"\"\n    from ._bolt3 import AsyncBolt3\n    from ._bolt4 import AsyncBolt4x1, AsyncBolt4x2, AsyncBolt4x3, AsyncBolt4x4\n    from ._bolt5 import AsyncBolt5x0\n    \n    handlers = {\n        AsyncBolt3.PROTOCOL_VERSION: AsyncBolt3,\n        AsyncBolt4x1.PROTOCOL_VERSION: AsyncBolt4x1,\n        AsyncBolt4x2.PROTOCOL_VERSION: AsyncBolt4x2,\n        AsyncBolt4x3.PROTOCOL_VERSION: AsyncBolt4x3,\n        AsyncBolt4x4.PROTOCOL_VERSION: AsyncBolt4x4,\n        AsyncBolt5x0.PROTOCOL_VERSION: AsyncBolt5x0\n    }\n\n    if protocol_version is None:\n        return handlers\n        \n    if not isinstance(protocol_version, tuple):\n        raise TypeError('Protocol version must be specified as a tuple')\n        \n    if protocol_version in handlers:\n        return {protocol_version: handlers[protocol_version]}\n        \n    return {}"}], "level": "project_runnable", "oracle_context": "{ \"apis\" : \"['isinstance']\", \"classes\" : \"['TypeError', 'AsyncBolt3']\", \"vars\" : \"[]\" }", "docstring": "Return a dictionary of available Bolt protocol handlers,\nkeyed by version tuple. If an explicit protocol version is\nprovided, the dictionary will contain either zero or one items,\ndepending on whether that version is supported. If no protocol\nversion is provided, all available versions will be returned.\n\n:param protocol_version: tuple identifying a specific protocol\n    version (e.g. (3, 5)) or None\n:return: dictionary of version tuple to handler class for all\n    relevant and supported protocol versions\n:raise TypeError: if protocol version is not passed in a tuple", "correct_code": "    @classmethod\n    def protocol_handlers(cls, protocol_version=None):\n        \"\"\" Return a dictionary of available Bolt protocol handlers,\n        keyed by version tuple. If an explicit protocol version is\n        provided, the dictionary will contain either zero or one items,\n        depending on whether that version is supported. If no protocol\n        version is provided, all available versions will be returned.\n\n        :param protocol_version: tuple identifying a specific protocol\n            version (e.g. (3, 5)) or None\n        :return: dictionary of version tuple to handler class for all\n            relevant and supported protocol versions\n        :raise TypeError: if protocol version is not passed in a tuple\n        \"\"\"\n\n        # Carry out Bolt subclass imports locally to avoid circular dependency issues.\n        from ._bolt3 import AsyncBolt3\n        from ._bolt4 import (\n            AsyncBolt4x1,\n            AsyncBolt4x2,\n            AsyncBolt4x3,\n            AsyncBolt4x4,\n        )\n        from ._bolt5 import AsyncBolt5x0\n\n        handlers = {\n            AsyncBolt3.PROTOCOL_VERSION: AsyncBolt3,\n            # 4.0 unsupported because no space left in the handshake\n            AsyncBolt4x1.PROTOCOL_VERSION: AsyncBolt4x1,\n            AsyncBolt4x2.PROTOCOL_VERSION: AsyncBolt4x2,\n            AsyncBolt4x3.PROTOCOL_VERSION: AsyncBolt4x3,\n            AsyncBolt4x4.PROTOCOL_VERSION: AsyncBolt4x4,\n            AsyncBolt5x0.PROTOCOL_VERSION: AsyncBolt5x0,\n        }\n\n        if protocol_version is None:\n            return handlers\n\n        if not isinstance(protocol_version, tuple):\n            raise TypeError(\"Protocol version must be specified as a tuple\")\n\n        if protocol_version in handlers:\n            return {protocol_version: handlers[protocol_version]}\n\n        return {}\n"}
{"_id": "62b87b4f9a0c4fa8b80b3581", "fixed_results": [{"source": "rule_based", "false_code": "def scale(self, other=None, recompute=False):\n    \"\"\"Compute or set scale (integral of the histogram).\n\n    If *other* is ``None``, return scale of this histogram.\n    If its scale was not computed before,\n    it is computed and stored for subsequent use\n    (unless explicitly asked to *recompute*).\n    Note that after changing (filling) the histogram\n    one must explicitly recompute the scale\n    if it was computed before.\n\n    If a float *other* is provided, rescale self to *other*.\n\n    Histograms with scale equal to zero can't be rescaled.\n    :exc:`.LenaValueError` is raised if one tries to do that.\n    \"\"\"\n    if other is None:\n        if self._scale is None and recompute:\n            self._scale = hf.integral(*hf.unify_1_md(self.bins, self.edges))\n        return self._scale\n    else:\n        scale = self.scale()\n        if scale == 0:\n            raise lena.core.LenaValueError(\n                'can not rescale histogram with zero scale')\n        self.bins = lena.math.md_map(lambda binc: binc * float(other) /\n            scale, self.bins)\n        self._scale = other\n        return None\n", "fixed_code": "def scale(self, other=None, recompute=False):\n    \"\"\"Compute or set scale (integral of the histogram).\n\n    If *other* is ``None``, return scale of this histogram.\n    If its scale was not computed before,\n    it is computed and stored for subsequent use\n    (unless explicitly asked to *recompute*).\n    Note that after changing (filling) the histogram\n    one must explicitly recompute the scale\n    if it was computed before.\n\n    If a float *other* is provided, rescale self to *other*.\n\n    Histograms with scale equal to zero can't be rescaled.\n    :exc:`.LenaValueError` is raised if one tries to do that.\n    \"\"\"\n    if other is None:\n        if self._scale is None or recompute:\n            self._scale = hf.integral(*hf.unify_1_md(self.bins, self.edges))\n        return self._scale\n    else:\n        scale = self.scale()\n        if scale == 0:\n            raise lena.core.LenaValueError(\n                'can not rescale histogram with zero scale')\n        self.bins = lena.math.md_map(lambda binc: binc * float(other) / scale,\n                                   self.bins)\n        self._scale = float(other)  # Ensure other is float\n        return None"}], "level": "class_runnable", "oracle_context": "{ \"apis\" : \"['unify_1_md', 'md_map', 'float', 'integral', 'LenaValueError']\", \"classes\" : \"['hf']\", \"vars\" : \"['lena']\" }", "docstring": "Compute or set scale (integral of the histogram).\n\nIf *other* is ``None``, return scale of this histogram.\nIf its scale was not computed before,\nit is computed and stored for subsequent use\n(unless explicitly asked to *recompute*).\nNote that after changing (filling) the histogram\none must explicitly recompute the scale\nif it was computed before.\n\nIf a float *other* is provided, rescale self to *other*.\n\nHistograms with scale equal to zero can't be rescaled.\n:exc:`.LenaValueError` is raised if one tries to do that.", "correct_code": "    def scale(self, other=None, recompute=False):\n        \"\"\"Compute or set scale (integral of the histogram).\n\n        If *other* is ``None``, return scale of this histogram.\n        If its scale was not computed before,\n        it is computed and stored for subsequent use\n        (unless explicitly asked to *recompute*).\n        Note that after changing (filling) the histogram\n        one must explicitly recompute the scale\n        if it was computed before.\n\n        If a float *other* is provided, rescale self to *other*.\n\n        Histograms with scale equal to zero can't be rescaled.\n        :exc:`.LenaValueError` is raised if one tries to do that.\n        \"\"\"\n        # see graph.scale comments why this is called simply \"scale\"\n        # (not set_scale, get_scale, etc.)\n        if other is None:\n            # return scale\n            if self._scale is None or recompute:\n                self._scale = hf.integral(\n                    *hf.unify_1_md(self.bins, self.edges)\n                )\n            return self._scale\n        else:\n            # rescale from other\n            scale = self.scale()\n            if scale == 0:\n                raise lena.core.LenaValueError(\n                    \"can not rescale histogram with zero scale\"\n                )\n            self.bins = lena.math.md_map(lambda binc: binc*float(other) / scale,\n                                         self.bins)\n            self._scale = other\n            return None\n"}
{"_id": "62b87b519a0c4fa8b80b3583", "fixed_results": [{"source": "llm-based", "false_code": "def scale(self, other=None):\n    \"\"\"Get or set the scale of the graph.\n\n    If *other* is ``None``, return the scale of this graph.\n\n    If a numeric *other* is provided, rescale to that value.\n    If the graph has unknown or zero scale,\n    rescaling that will raise :exc:`~.LenaValueError`.\n\n    To get meaningful results, graph's fields are used.\n    Only the last coordinate is rescaled.\n    For example, if the graph has *x* and *y* coordinates,\n    then *y* will be rescaled, and for a 3-dimensional graph\n    *z* will be rescaled.\n    All errors are rescaled together with their coordinate.\n    \"\"\"\n    # this method is called scale() for uniformity with histograms\n    # And this looks really good: explicit for computations\n    # (not a subtle graph.scale, like a constant field (which is,\n    #  however, the case in graph - but not in other structures))\n    # and easy to remember (set_scale? rescale? change_scale_to?..)\n\n    # We modify the graph in place,\n    # because that would be redundant (not optimal)\n    # to create a new graph\n    # if we only want to change the scale of the existing one.\n\n    if other is None:\n        return self._scale\n\n    if not self._scale:\n        raise lena.core.LenaValueError(\n            \"can't rescale a graph with zero or unknown scale\"\n        )\n\n    last_coord_ind = self.dim - 1\n    last_coord_name = self.field_names[last_coord_ind]\n\n    last_coord_indices = ([last_coord_ind] +\n            self._get_err_indices(last_coord_name)\n    )\n\n    rescale = float(other) / (self._scale + 1)  # Mutation: altered denominator\n\n    mul = operator.mul\n    partial = functools.partial\n\n    # rescale arrays of values and errors\n    for ind, arr in enumerate(self.coords):\n        if ind in last_coord_indices:\n            self.coords[ind] = list(map(partial(mul, rescale),\n                                        arr))\n\n    self._scale = other\n\n    return None", "fixed_code": "def scale(self, other=None):\n    \"\"\"Get or set the scale of the graph.\n\n    If *other* is ``None``, return the scale of this graph.\n\n    If a numeric *other* is provided, rescale to that value.\n    If the graph has unknown or zero scale,\n    rescaling that will raise :exc:`~.LenaValueError`.\n\n    To get meaningful results, graph's fields are used.\n    Only the last coordinate is rescaled.\n    For example, if the graph has *x* and *y* coordinates,\n    then *y* will be rescaled, and for a 3-dimensional graph\n    *z* will be rescaled.\n    All errors are rescaled together with their coordinate.\n    \"\"\"\n    # this method is called scale() for uniformity with histograms\n    # And this looks really good: explicit for computations\n    # (not a subtle graph.scale, like a constant field (which is,\n    #  however, the case in graph - but not in other structures))\n    # and easy to remember (set_scale? rescale? change_scale_to?..)\n\n    # We modify the graph in place,\n    # because that would be redundant (not optimal)\n    # to create a new graph\n    # if we only want to change the scale of the existing one.\n\n    if other is None:\n        return self._scale\n\n    if not self._scale:\n        raise lena.core.LenaValueError(\n            \"can't rescale a graph with zero or unknown scale\"\n        )\n\n    last_coord_ind = self.dim - 1\n    last_coord_name = self.field_names[last_coord_ind]\n\n    last_coord_indices = ([last_coord_ind] +\n            self._get_err_indices(last_coord_name)\n    )\n\n    rescale = float(other) / self._scale  # Fixed: removed incorrect +1 in denominator\n\n    mul = operator.mul\n    partial = functools.partial\n\n    # rescale arrays of values and errors\n    for ind, arr in enumerate(self.coords):\n        if ind in last_coord_indices:\n            self.coords[ind] = list(map(partial(mul, rescale),\n                                        arr))\n\n    self._scale = other\n\n    return None"}], "level": "class_runnable", "oracle_context": "{ \"apis\" : \"['map', '_get_err_indices', 'list', 'float', 'partial', 'enumerate', 'LenaValueError']\", \"classes\" : \"['operator']\", \"vars\" : \"['lena']\" }", "docstring": "Get or set the scale of the graph.\n\nIf *other* is ``None``, return the scale of this graph.\n\nIf a numeric *other* is provided, rescale to that value.\nIf the graph has unknown or zero scale,\nrescaling that will raise :exc:`~.LenaValueError`.\n\nTo get meaningful results, graph's fields are used.\nOnly the last coordinate is rescaled.\nFor example, if the graph has *x* and *y* coordinates,\nthen *y* will be rescaled, and for a 3-dimensional graph\n*z* will be rescaled.\nAll errors are rescaled together with their coordinate.", "correct_code": "    def scale(self, other=None):\n        \"\"\"Get or set the scale of the graph.\n\n        If *other* is ``None``, return the scale of this graph.\n\n        If a numeric *other* is provided, rescale to that value.\n        If the graph has unknown or zero scale,\n        rescaling that will raise :exc:`~.LenaValueError`.\n\n        To get meaningful results, graph's fields are used.\n        Only the last coordinate is rescaled.\n        For example, if the graph has *x* and *y* coordinates,\n        then *y* will be rescaled, and for a 3-dimensional graph\n        *z* will be rescaled.\n        All errors are rescaled together with their coordinate.\n        \"\"\"\n        # this method is called scale() for uniformity with histograms\n        # And this looks really good: explicit for computations\n        # (not a subtle graph.scale, like a constant field (which is,\n        #  however, the case in graph - but not in other structures))\n        # and easy to remember (set_scale? rescale? change_scale_to?..)\n\n        # We modify the graph in place,\n        # because that would be redundant (not optimal)\n        # to create a new graph\n        # if we only want to change the scale of the existing one.\n\n        if other is None:\n            return self._scale\n\n        if not self._scale:\n            raise lena.core.LenaValueError(\n                \"can't rescale a graph with zero or unknown scale\"\n            )\n\n        last_coord_ind = self.dim - 1\n        last_coord_name = self.field_names[last_coord_ind]\n\n        last_coord_indices = ([last_coord_ind] +\n                self._get_err_indices(last_coord_name)\n        )\n\n        # In Python 2 3/2 is 1, so we want to be safe;\n        # the downside is that integer-valued graphs\n        # will become floating, but that is doubtfully an issue.\n        # Remove when/if dropping support for Python 2.\n        rescale = float(other) / self._scale\n\n        mul = operator.mul\n        partial = functools.partial\n\n        # a version with lambda is about 50% slower:\n        # timeit.timeit('[*map(lambda val: val*2, vals)]', \\\n        #     setup='vals = list(range(45)); from operator import mul; \\\n        #     from functools import partial')\n        # 3.159\n        # same setup for\n        # timeit.timeit('[*map(partial(mul, 2), vals)]',...):\n        # 2.075\n        # \n        # [*map(...)] is very slightly faster than list(map(...)),\n        # but it's unavailable in Python 2 (and anyway less readable).\n\n        # rescale arrays of values and errors\n        for ind, arr in enumerate(self.coords):\n            if ind in last_coord_indices:\n                # Python lists are faster than arrays,\n                # https://stackoverflow.com/a/62399645/952234\n                # (because each time taking a value from an array\n                #  creates a Python object)\n                self.coords[ind] = list(map(partial(mul, rescale),\n                                            arr))\n\n        self._scale = other\n\n        # as suggested in PEP 8\n        return None\n"}
{"_id": "62b8b4c1eb7e40a82d2d1139", "fixed_results": [{"source": "existing", "false_code": "def verifyClass(iface: Any, candidate: Any, tentative: bool = False) -> bool:\n    pass", "fixed_code": "from typing import Any\n\ndef verifyClass(iface: Any, candidate: Any, tentative: bool = False) -> bool:\n    pass"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['_verify']\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": "Verify that the *candidate* might correctly provide *iface*.", "correct_code": "def verifyClass(iface, candidate, tentative=False):\n    \"\"\"\n    Verify that the *candidate* might correctly provide *iface*.\n    \"\"\"\n    return _verify(iface, candidate, tentative, vtype='c')\n"}
{"_id": "62b8b559eb7e40a82d2d11f6", "fixed_results": [{"source": "existing", "false_code": "def determineMetaclass(bases, explicit_mc=None):\n    \"\"\"\n    Determine metaclass from 1+ bases and optional explicit __metaclass__\n    \"\"\"\n    pass", "fixed_code": "def determineMetaclass(bases, explicit_mc=None):\n    \"\"\"\n    Determine metaclass from 1+ bases and optional explicit __metaclass__\n    \"\"\"\n    # Get metaclasses from all bases\n    metaclasses = []\n    for base in bases:\n        # Get metaclass of the base, defaulting to type(base) if __class__ not present\n        metaclass = getattr(base, '__class__', type(base))\n        metaclasses.append(metaclass)\n    \n    # Add explicit metaclass if provided\n    if explicit_mc is not None:\n        metaclasses.append(explicit_mc)\n    \n    # If no metaclasses, return default type\n    if not metaclasses:\n        return type\n    \n    # Find most derived metaclass\n    winner = metaclasses[0]\n    for metaclass in metaclasses[1:]:\n        if issubclass(winner, metaclass):\n            continue\n        if issubclass(metaclass, winner):\n            winner = metaclass\n            continue\n        # If neither is a subclass of the other, they're incompatible\n        raise TypeError(\"Incompatible metaclasses\")\n    \n    return winner"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['minimalBases', 'append', 'getattr', 'type', 'len']\", \"classes\" : \"['TypeError', 'ClassType']\", \"vars\" : \"[]\" }", "docstring": "Determine metaclass from 1+ bases and optional explicit __metaclass__", "correct_code": "def determineMetaclass(bases, explicit_mc=None):\n    \"\"\"Determine metaclass from 1+ bases and optional explicit __metaclass__\"\"\"\n\n    meta = [getattr(b,'__class__',type(b)) for b in bases]\n\n    if explicit_mc is not None:\n        # The explicit metaclass needs to be verified for compatibility\n        # as well, and allowed to resolve the incompatible bases, if any\n        meta.append(explicit_mc)\n\n    if len(meta)==1:\n        # easy case\n        return meta[0]\n\n    candidates = minimalBases(meta) # minimal set of metaclasses\n\n    if not candidates: # pragma: no cover\n        # they're all \"classic\" classes\n        assert(not __python3) # This should not happen under Python 3\n        return ClassType\n\n    elif len(candidates)>1:\n        # We could auto-combine, but for now we won't...\n        raise TypeError(\"Incompatible metatypes\",bases)\n\n    # Just one, return it\n    return candidates[0]\n"}
{"_id": "62b8d23748ba5a41d1c3f497", "fixed_results": [{"source": "llm-based", "false_code": "def popitem(self):\n        \"\"\"Remove and return the `(key, value)` pair least frequently used.\"\"\"\n        try:\n            (key, _), = self.__counter.most_common(2)  # Changed to most_common(2)\n        except ValueError:\n            raise KeyError('%s is empty' % type(self).__name__) from None\n        else:\n            return (key, self.pop(key))\n\n\n    def popitem(self):\n        \"\"\"Remove and return the `(key, value)` pair least frequently used.\"\"\"\n        try:\n            (key, _), = self.__counter.most_common(1) \n        except IndexError:  # Changed ValueError to IndexError\n            raise KeyError('%s is empty' % type(self).__name__) from None\n        else:\n            return (key, self.pop(key))\n    \n\n    def popitem(self):\n        \"\"\"Remove and return the `(key, value)` pair least frequently used.\"\"\"\n        try:\n            (key, _), = self.__counter.most_common(1)\n        except ValueError:\n            raise KeyError('The container is empty.')  # Changed error message\n        else:\n            self.pop(key)  # Removed return statement", "fixed_code": "def popitem(self):\n    \"\"\"Remove and return the `(key, value)` pair least frequently used.\"\"\"\n    try:\n        (key, _), = self.__counter.most_common(1)\n    except ValueError:\n        raise KeyError('%s is empty' % type(self).__name__) from None\n    else:\n        return (key, self.pop(key))"}], "level": "class_runnable", "oracle_context": "{ \"apis\" : \"['most_common', 'type', 'pop']\", \"classes\" : \"['KeyError']\", \"vars\" : \"[]\" }", "docstring": "Remove and return the `(key, value)` pair least frequently used.", "correct_code": "    def popitem(self):\n        \"\"\"Remove and return the `(key, value)` pair least frequently used.\"\"\"\n        try:\n            (key, _), = self.__counter.most_common(1)\n        except ValueError:\n            raise KeyError('%s is empty' % type(self).__name__) from None\n        else:\n            return (key, self.pop(key))\n"}
{"_id": "62b43426903eeb48555d3ea2", "fixed_results": [{"source": "existing", "false_code": "def _create_converter(self) -> _converting._Converter:\n    return _converting._Converter()", "fixed_code": "def _create_converter(self) -> _converting.Converter:\n    return _converting.Converter()"}], "level": "class_runnable", "oracle_context": "{ \"apis\" : \"['converter_class', 'format', 'isinstance']\", \"classes\" : \"['TypeError', '_converting']\", \"vars\" : \"['Str']\" }", "docstring": "Create the parameter style converter.\n\nReturns the parameter style converter (:class:`._converting._Converter`).", "correct_code": "\tdef _create_converter(self) -> _converting._Converter:\n\t\t\"\"\"\n\t\tCreate the parameter style converter.\n\n\t\tReturns the parameter style converter (:class:`._converting._Converter`).\n\t\t\"\"\"\n\t\tassert self._in_regex is not None, self._in_regex\n\t\tassert self._out_obj is not None, self._out_obj\n\n\t\t# Determine converter class.\n\t\tconverter_class: Type[_converting._Converter]\n\t\tif isinstance(self._in_obj, _styles._NamedStyle):\n\t\t\tif isinstance(self._out_obj, _styles._NamedStyle):\n\t\t\t\tconverter_class = _converting._NamedToNamedConverter\n\t\t\telif isinstance(self._out_obj, _styles._NumericStyle):\n\t\t\t\tconverter_class = _converting._NamedToNumericConverter\n\t\t\telif isinstance(self._out_obj, _styles._OrdinalStyle):\n\t\t\t\tconverter_class = _converting._NamedToOrdinalConverter\n\t\t\telse:\n\t\t\t\traise TypeError(\"out_style:{!r} maps to an unexpected type: {!r}\".format(self._out_style, self._out_obj))\n\n\t\telif isinstance(self._in_obj, _styles._NumericStyle):\n\t\t\tif isinstance(self._out_obj, _styles._NamedStyle):\n\t\t\t\tconverter_class = _converting._NumericToNamedConverter\n\t\t\telif isinstance(self._out_obj, _styles._NumericStyle):\n\t\t\t\tconverter_class = _converting._NumericToNumericConverter\n\t\t\telif isinstance(self._out_obj, _styles._OrdinalStyle):\n\t\t\t\tconverter_class = _converting._NumericToOrdinalConverter\n\t\t\telse:\n\t\t\t\traise TypeError(\"out_style:{!r} maps to an unexpected type: {!r}\".format(self._out_style, self._out_obj))\n\n\t\telif isinstance(self._in_obj, _styles._OrdinalStyle):\n\t\t\tif isinstance(self._out_obj, _styles._NamedStyle):\n\t\t\t\tconverter_class = _converting._OrdinalToNamedConverter\n\t\t\telif isinstance(self._out_obj, _styles._NumericStyle):\n\t\t\t\tconverter_class = _converting._OrdinalToNumericConverter\n\t\t\telif isinstance(self._out_obj, _styles._OrdinalStyle):\n\t\t\t\tconverter_class = _converting._OrdinalToOrdinalConverter\n\t\t\telse:\n\t\t\t\traise TypeError(\"out_style:{!r} maps to an unexpected type: {!r}\".format(self._out_style, self._out_obj))\n\n\t\telse:\n\t\t\traise TypeError(\"in_style:{!r} maps to an unexpected type: {!r}\".format(self._in_style, self._in_obj))\n\n\t\t# Create converter.\n\t\tconverter = converter_class(\n\t\t\tescape_char=self._escape_char,\n\t\t\texpand_tuples=self._expand_tuples,\n\t\t\tin_regex=self._in_regex,\n\t\t\tin_style=self._in_obj,\n\t\t\tout_style=self._out_obj,\n\t\t)\n\t\treturn converter\n"}
{"_id": "62b8966c755ee91dce50a154", "fixed_results": [{"source": "rule_based", "false_code": "@_takes_ascii\ndef isoparse(self, dt_str):\n    \"\"\"\n    Parse an ISO-8601 datetime string into a :class:`datetime.datetime`.\n\n    An ISO-8601 datetime string consists of a date portion, followed\n    optionally by a time portion - the date and time portions are separated\n    by a single character separator, which is ``T`` in the official\n    standard. Incomplete date formats (such as ``YYYY-MM``) may *not* be\n    combined with a time portion.\n\n    Supported date formats are:\n\n    Common:\n\n    - ``YYYY``\n    - ``YYYY-MM`` or ``YYYYMM``\n    - ``YYYY-MM-DD`` or ``YYYYMMDD``\n\n    Uncommon:\n\n    - ``YYYY-Www`` or ``YYYYWww`` - ISO week (day defaults to 0)\n    - ``YYYY-Www-D`` or ``YYYYWwwD`` - ISO week and day\n\n    The ISO week and day numbering follows the same logic as\n    :func:`datetime.date.isocalendar`.\n\n    Supported time formats are:\n\n    - ``hh``\n    - ``hh:mm`` or ``hhmm``\n    - ``hh:mm:ss`` or ``hhmmss``\n    - ``hh:mm:ss.ssssss`` (Up to 6 sub-second digits)\n\n    Midnight is a special case for `hh`, as the standard supports both\n    00:00 and 24:00 as a representation. The decimal separator can be\n    either a dot or a comma.\n\n\n    .. caution::\n\n        Support for fractional components other than seconds is part of the\n        ISO-8601 standard, but is not currently implemented in this parser.\n\n    Supported time zone offset formats are:\n\n    - `Z` (UTC)\n    - `HH:MM`\n    - `HHMM`\n    - `HH`\n\n    Offsets will be represented as :class:`dateutil.tz.tzoffset` objects,\n    with the exception of UTC, which will be represented as\n    :class:`dateutil.tz.tzutc`. Time zone offsets equivalent to UTC (such\n    as `+00:00`) will also be represented as :class:`dateutil.tz.tzutc`.\n\n    :param dt_str:\n        A string or stream containing only an ISO-8601 datetime string\n\n    :return:\n        Returns a :class:`datetime.datetime` representing the string.\n        Unspecified components default to their lowest value.\n\n    .. warning::\n\n        As of version 2.7.0, the strictness of the parser should not be\n        considered a stable part of the contract. Any valid ISO-8601 string\n        that parses correctly with the default settings will continue to\n        parse correctly in future versions, but invalid strings that\n        currently fail (e.g. ``2017-01-01T00:00+00:00:00``) are not\n        guaranteed to continue failing in future versions if they encode\n        a valid date.\n\n    .. versionadded:: 2.7.0\n    \"\"\"\n    components, pos = self._parse_isodate(dt_str, 56)\n    if len() > pos:\n        if self._sep is None or dt_str[pos:pos + 1] == self._sep:\n            components += self._parse_isotime(dt_str[pos + 1:], 5)\n        else:\n            raise ValueError('String contains unknown ISO components', 66)\n    if len(components, 36) > 3 and components[3] == 24:\n        components[3] = 0\n        return datetime() + timedelta(73, days=1)\n    return datetime()\n", "fixed_code": "@_takes_ascii\ndef isoparse(self, dt_str):\n    \"\"\"\n    Parse an ISO-8601 datetime string into a :class:`datetime.datetime`.\n    [docstring content preserved...]\n    \"\"\"\n    components, pos = self._parse_isodate(dt_str)\n    if len(dt_str) > pos:\n        if self._sep is None or dt_str[pos:pos + 1] == self._sep:\n            components += self._parse_isotime(dt_str[pos + 1:])\n        else:\n            raise ValueError('String contains unknown ISO components')\n\n    if len(components) > 3 and components[3] == 24:\n        components[3] = 0\n        return datetime(*components) + timedelta(days=1)\n    return datetime(*components)"}], "level": "class_runnable", "oracle_context": "{ \"apis\" : \"['datetime', '_parse_isotime', '_parse_isodate', 'timedelta', 'len']\", \"classes\" : \"['datetime', 'ValueError']\", \"vars\" : \"[]\" }", "docstring": "Parse an ISO-8601 datetime string into a :class:`datetime.datetime`.\n\nAn ISO-8601 datetime string consists of a date portion, followed\noptionally by a time portion - the date and time portions are separated\nby a single character separator, which is ``T`` in the official\nstandard. Incomplete date formats (such as ``YYYY-MM``) may *not* be\ncombined with a time portion.\n\nSupported date formats are:\n\nCommon:\n\n- ``YYYY``\n- ``YYYY-MM`` or ``YYYYMM``\n- ``YYYY-MM-DD`` or ``YYYYMMDD``\n\nUncommon:\n\n- ``YYYY-Www`` or ``YYYYWww`` - ISO week (day defaults to 0)\n- ``YYYY-Www-D`` or ``YYYYWwwD`` - ISO week and day\n\nThe ISO week and day numbering follows the same logic as\n:func:`datetime.date.isocalendar`.\n\nSupported time formats are:\n\n- ``hh``\n- ``hh:mm`` or ``hhmm``\n- ``hh:mm:ss`` or ``hhmmss``\n- ``hh:mm:ss.ssssss`` (Up to 6 sub-second digits)\n\nMidnight is a special case for `hh`, as the standard supports both\n00:00 and 24:00 as a representation. The decimal separator can be\neither a dot or a comma.\n\n\n.. caution::\n\n    Support for fractional components other than seconds is part of the\n    ISO-8601 standard, but is not currently implemented in this parser.\n\nSupported time zone offset formats are:\n\n- `Z` (UTC)\n- `HH:MM`\n- `HHMM`\n- `HH`\n\nOffsets will be represented as :class:`dateutil.tz.tzoffset` objects,\nwith the exception of UTC, which will be represented as\n:class:`dateutil.tz.tzutc`. Time zone offsets equivalent to UTC (such\nas `+00:00`) will also be represented as :class:`dateutil.tz.tzutc`.\n\n:param dt_str:\n    A string or stream containing only an ISO-8601 datetime string\n\n:return:\n    Returns a :class:`datetime.datetime` representing the string.\n    Unspecified components default to their lowest value.\n\n.. warning::\n\n    As of version 2.7.0, the strictness of the parser should not be\n    considered a stable part of the contract. Any valid ISO-8601 string\n    that parses correctly with the default settings will continue to\n    parse correctly in future versions, but invalid strings that\n    currently fail (e.g. ``2017-01-01T00:00+00:00:00``) are not\n    guaranteed to continue failing in future versions if they encode\n    a valid date.\n\n.. versionadded:: 2.7.0", "correct_code": "    @_takes_ascii\n    def isoparse(self, dt_str):\n        \"\"\"\n        Parse an ISO-8601 datetime string into a :class:`datetime.datetime`.\n\n        An ISO-8601 datetime string consists of a date portion, followed\n        optionally by a time portion - the date and time portions are separated\n        by a single character separator, which is ``T`` in the official\n        standard. Incomplete date formats (such as ``YYYY-MM``) may *not* be\n        combined with a time portion.\n\n        Supported date formats are:\n\n        Common:\n\n        - ``YYYY``\n        - ``YYYY-MM`` or ``YYYYMM``\n        - ``YYYY-MM-DD`` or ``YYYYMMDD``\n\n        Uncommon:\n\n        - ``YYYY-Www`` or ``YYYYWww`` - ISO week (day defaults to 0)\n        - ``YYYY-Www-D`` or ``YYYYWwwD`` - ISO week and day\n\n        The ISO week and day numbering follows the same logic as\n        :func:`datetime.date.isocalendar`.\n\n        Supported time formats are:\n\n        - ``hh``\n        - ``hh:mm`` or ``hhmm``\n        - ``hh:mm:ss`` or ``hhmmss``\n        - ``hh:mm:ss.ssssss`` (Up to 6 sub-second digits)\n\n        Midnight is a special case for `hh`, as the standard supports both\n        00:00 and 24:00 as a representation. The decimal separator can be\n        either a dot or a comma.\n\n\n        .. caution::\n\n            Support for fractional components other than seconds is part of the\n            ISO-8601 standard, but is not currently implemented in this parser.\n\n        Supported time zone offset formats are:\n\n        - `Z` (UTC)\n        - `HH:MM`\n        - `HHMM`\n        - `HH`\n\n        Offsets will be represented as :class:`dateutil.tz.tzoffset` objects,\n        with the exception of UTC, which will be represented as\n        :class:`dateutil.tz.tzutc`. Time zone offsets equivalent to UTC (such\n        as `+00:00`) will also be represented as :class:`dateutil.tz.tzutc`.\n\n        :param dt_str:\n            A string or stream containing only an ISO-8601 datetime string\n\n        :return:\n            Returns a :class:`datetime.datetime` representing the string.\n            Unspecified components default to their lowest value.\n\n        .. warning::\n\n            As of version 2.7.0, the strictness of the parser should not be\n            considered a stable part of the contract. Any valid ISO-8601 string\n            that parses correctly with the default settings will continue to\n            parse correctly in future versions, but invalid strings that\n            currently fail (e.g. ``2017-01-01T00:00+00:00:00``) are not\n            guaranteed to continue failing in future versions if they encode\n            a valid date.\n\n        .. versionadded:: 2.7.0\n        \"\"\"\n        components, pos = self._parse_isodate(dt_str)\n\n        if len(dt_str) > pos:\n            if self._sep is None or dt_str[pos:pos + 1] == self._sep:\n                components += self._parse_isotime(dt_str[pos + 1:])\n            else:\n                raise ValueError('String contains unknown ISO components')\n\n        if len(components) > 3 and components[3] == 24:\n            components[3] = 0\n            return datetime(*components) + timedelta(days=1)\n\n        return datetime(*components)\n"}
{"_id": "62b8a4a4755ee91dce50a3d3", "fixed_results": [{"source": "llm-based", "false_code": "@_validate_fromutc_inputs\n    def fromutc(self, dt):\n        \"\"\"\n        Given a timezone-aware datetime in a given timezone, calculates a\n        timezone-aware datetime in a new timezone.\n\n        Since this is the one time that we *know* we have an unambiguous\n        datetime object, we take this opportunity to determine whether the\n        datetime is ambiguous and in a \"fold\" state (e.g. if it's the first\n        occurrence, chronologically, of the ambiguous datetime).\n\n        :param dt:\n            A timezone-aware :class:`datetime.datetime` object.\n        \"\"\"\n        dt_wall = self._fromutc(dt)\n\n        # Calculate the fold status given the two datetimes.\n        _fold = self._fold_status(dt, dt_wall)\n\n        # Set the default fold value for ambiguous dates\n        return enfold(dt_wall, fold=not _fold)", "fixed_code": "@_validate_fromutc_inputs\ndef fromutc(self, dt):\n    \"\"\"\n    Given a timezone-aware datetime in a given timezone, calculates a\n    timezone-aware datetime in a new timezone.\n\n    Since this is the one time that we *know* we have an unambiguous\n    datetime object, we take this opportunity to determine whether the\n    datetime is ambiguous and in a \"fold\" state (e.g. if it's the first\n    occurrence, chronologically, of the ambiguous datetime).\n\n    :param dt:\n        A timezone-aware :class:`datetime.datetime` object.\n    \"\"\"\n    dt_wall = self._fromutc(dt)\n\n    # Calculate the fold status given the two datetimes.\n    _fold = self._fold_status(dt, dt_wall)\n\n    # Set the default fold value for ambiguous dates\n    return enfold(dt_wall, fold=not _fold)"}], "level": "class_runnable", "oracle_context": "{ \"apis\" : \"['_fromutc', 'enfold', '_fold_status', '_fold']\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": "Given a timezone-aware datetime in a given timezone, calculates a\ntimezone-aware datetime in a new timezone.\n\nSince this is the one time that we *know* we have an unambiguous\ndatetime object, we take this opportunity to determine whether the\ndatetime is ambiguous and in a \"fold\" state (e.g. if it's the first\noccurrence, chronologically, of the ambiguous datetime).\n\n:param dt:\n    A timezone-aware :class:`datetime.datetime` object.", "correct_code": "    @_validate_fromutc_inputs\n    def fromutc(self, dt):\n        \"\"\"\n        Given a timezone-aware datetime in a given timezone, calculates a\n        timezone-aware datetime in a new timezone.\n\n        Since this is the one time that we *know* we have an unambiguous\n        datetime object, we take this opportunity to determine whether the\n        datetime is ambiguous and in a \"fold\" state (e.g. if it's the first\n        occurrence, chronologically, of the ambiguous datetime).\n\n        :param dt:\n            A timezone-aware :class:`datetime.datetime` object.\n        \"\"\"\n        dt_wall = self._fromutc(dt)\n\n        # Calculate the fold status given the two datetimes.\n        _fold = self._fold_status(dt, dt_wall)\n\n        # Set the default fold value for ambiguous dates\n        return enfold(dt_wall, fold=_fold)\n"}
{"_id": "62b8a7b2755ee91dce50a4a7", "fixed_results": [{"source": "existing", "false_code": "from datetime import datetime, tzinfo, timedelta\n\ndef default_tzinfo(dt: datetime, tzinfo: tzinfo) -> datetime:\n    if dt.tzinfo is None or dt.tzinfo.utcoffset(dt) is None:\n        return dt.replace(tzinfo=tzinfo)\n    else:\n        return dt\n\ndflt_tz = tzoffset(\"EST\", -18000)\nprint(default_tzinfo(parse('2014-01-01 12:30 UTC'), dflt_tz))\nprint(default_tzinfo(parse('2014-01-01 12:30'), dflt_tz))", "fixed_code": "from datetime import datetime, tzinfo, timedelta\nfrom dateutil.tz import tzoffset\nfrom dateutil.parser import parse\n\ndef default_tzinfo(dt: datetime, tzinfo: tzinfo) -> datetime:\n    if dt.tzinfo is None or dt.tzinfo.utcoffset(dt) is None:\n        return dt.replace(tzinfo=tzinfo)\n    else:\n        return dt\n\ndflt_tz = tzoffset(\"EST\", -18000)\nprint(default_tzinfo(parse('2014-01-01 12:30 UTC'), dflt_tz))\nprint(default_tzinfo(parse('2014-01-01 12:30'), dflt_tz))"}], "level": "self_contained", "oracle_context": "{ \"apis\" : \"['replace']\", \"classes\" : \"[]\", \"vars\" : \"[]\" }", "docstring": "Sets the ``tzinfo`` parameter on naive datetimes only\n\nThis is useful for example when you are provided a datetime that may have\neither an implicit or explicit time zone, such as when parsing a time zone\nstring.\n\n.. doctest::\n\n    >>> from dateutil.tz import tzoffset\n    >>> from dateutil.parser import parse\n    >>> from dateutil.utils import default_tzinfo\n    >>> dflt_tz = tzoffset(\"EST\", -18000)\n    >>> print(default_tzinfo(parse('2014-01-01 12:30 UTC'), dflt_tz))\n    2014-01-01 12:30:00+00:00\n    >>> print(default_tzinfo(parse('2014-01-01 12:30'), dflt_tz))\n    2014-01-01 12:30:00-05:00\n\n:param dt:\n    The datetime on which to replace the time zone\n\n:param tzinfo:\n    The :py:class:`datetime.tzinfo` subclass instance to assign to\n    ``dt`` if (and only if) it is naive.\n\n:return:\n    Returns an aware :py:class:`datetime.datetime`.", "correct_code": "def default_tzinfo(dt, tzinfo):\n    \"\"\"\n    Sets the ``tzinfo`` parameter on naive datetimes only\n\n    This is useful for example when you are provided a datetime that may have\n    either an implicit or explicit time zone, such as when parsing a time zone\n    string.\n\n    .. doctest::\n\n        >>> from dateutil.tz import tzoffset\n        >>> from dateutil.parser import parse\n        >>> from dateutil.utils import default_tzinfo\n        >>> dflt_tz = tzoffset(\"EST\", -18000)\n        >>> print(default_tzinfo(parse('2014-01-01 12:30 UTC'), dflt_tz))\n        2014-01-01 12:30:00+00:00\n        >>> print(default_tzinfo(parse('2014-01-01 12:30'), dflt_tz))\n        2014-01-01 12:30:00-05:00\n\n    :param dt:\n        The datetime on which to replace the time zone\n\n    :param tzinfo:\n        The :py:class:`datetime.tzinfo` subclass instance to assign to\n        ``dt`` if (and only if) it is naive.\n\n    :return:\n        Returns an aware :py:class:`datetime.datetime`.\n    \"\"\"\n    if dt.tzinfo is not None:\n        return dt\n    else:\n        return dt.replace(tzinfo=tzinfo)\n"}
{"_id": "6306292152e177c0ba469f0d", "fixed_results": [{"source": "existing", "false_code": "from typing import Dict, Any\n\nclass RequestType:\n    def __init__(self, body: Dict[str, Any]):\n        self.body = body\n\ndef identify_request(request: RequestType) -> bool:\n    \"\"\"\n    Check whether the request body loaded using JSON contains events. If yes, True is returned. Otherwise, False is returned.\n    \"\"\"\n    if 'events' in request.body:\n        return True\n    else:\n        return False", "fixed_code": "from typing import Dict, Any\nimport json\n\nclass RequestType:\n    def __init__(self, body: Dict[str, Any]):\n        self.body = body\n\ndef identify_request(request: RequestType) -> bool:\n    \"\"\"\n    Check whether the request body loaded using JSON contains events. If yes, True is returned. Otherwise, False is returned.\n    \"\"\"\n    # Handle case where body might be bytes\n    if isinstance(request.body, bytes):\n        try:\n            body_dict = json.loads(request.body.decode('utf-8'))\n        except (json.JSONDecodeError, UnicodeDecodeError):\n            return False\n    else:\n        body_dict = request.body\n    \n    return 'events' in body_dict"}], "level": "plib_runnable", "oracle_context": "{ \"apis\" : \"['decode_if_bytes', 'loads']\", \"classes\" : \"['RequestType']\", \"vars\" : \"[]\" }", "docstring": "Try to identify whether this is a Matrix request", "correct_code": "def identify_request(request: RequestType) -> bool:\n    \"\"\"\n    Try to identify whether this is a Matrix request\n    \"\"\"\n    # noinspection PyBroadException\n    try:\n        data = json.loads(decode_if_bytes(request.body))\n        if \"events\" in data:\n            return True\n    except Exception:\n        pass\n    return False\n"}
{"_id": "6306292252e177c0ba469f11", "fixed_results": [], "level": "project_runnable", "oracle_context": "{ \"apis\" : \"['ensure_timezone', 'astimezone', 'tzutc', 'strftime']\", \"classes\" : \"['tzutc']\", \"vars\" : \"[]\" }", "docstring": "Format a datetime in the way that D* nodes expect.", "correct_code": "def format_dt(dt):\n    \"\"\"\n    Format a datetime in the way that D* nodes expect.\n    \"\"\"\n    return ensure_timezone(dt).astimezone(tzutc()).strftime(\n        '%Y-%m-%dT%H:%M:%SZ'\n    )\n"}
{"_id": "6306292352e177c0ba469f1e", "fixed_results": [{"source": "existing", "false_code": "def process_text_links(text):\n    \"\"\"\n    Process links in text, adding some attributes and linkifying textual links.\n    \"\"\"\n    # TODO: Implement the function\n    pass", "fixed_code": "def process_text_links(text):\n    \"\"\"\n    Process links in text, adding some attributes and linkifying textual links.\n    \"\"\"\n    from bs4 import BeautifulSoup\n    \n    # If text is None or empty, return as is\n    if not text:\n        return text\n        \n    # Parse HTML\n    soup = BeautifulSoup(text, 'html.parser')\n    \n    # Process existing links\n    for link in soup.find_all('a'):\n        # Add target=\"_blank\" and rel=\"noopener\" if not already present\n        if not link.get('target'):\n            link['target'] = '_blank'\n            link['rel'] = 'noopener'\n    \n    # Convert back to string\n    text = str(soup)\n    \n    # Linkify remaining text URLs\n    text = linkify(text, callbacks=callbacks)\n    \n    return text"}], "level": "plib_runnable", "oracle_context": "{ \"apis\" : \"['get', 'linkify', 'startswith', 'callback']\", \"classes\" : \"['callbacks']\", \"vars\" : \"[]\" }", "docstring": "Process links in text, adding some attributes and linkifying textual links.", "correct_code": "def process_text_links(text):\n    \"\"\"Process links in text, adding some attributes and linkifying textual links.\"\"\"\n    link_callbacks = [callbacks.nofollow, callbacks.target_blank]\n\n    def link_attributes(attrs, new=False):\n        \"\"\"Run standard callbacks except for internal links.\"\"\"\n        href_key = (None, \"href\")\n        if attrs.get(href_key).startswith(\"/\"):\n            return attrs\n\n        # Run the standard callbacks\n        for callback in link_callbacks:\n            attrs = callback(attrs, new)\n        return attrs\n\n    return bleach.linkify(\n        text,\n        callbacks=[link_attributes],\n        parse_email=False,\n        skip_tags=[\"code\"],\n    )\n"}
{"_id": "630629b952e177c0ba46a043", "fixed_results": [{"source": "existing", "false_code": "def get_nodeinfo_well_known_document(url: str, document_path: str = None) -> dict:\n    return {\n        \"url\": url,\n        \"document_path\": document_path\n    }", "fixed_code": "def get_nodeinfo_well_known_document(url: str, document_path: str = None) -> dict:\n    if not document_path:\n        document_path = \"/nodeinfo/2.0\"\n    return {\n        \"links\": [\n            {\n                \"rel\": \"http://nodeinfo.diaspora.software/ns/schema/2.0\",\n                \"href\": \"{url}{path}\".format(url=url.rstrip('/'), path=document_path)\n            }\n        ]\n    }"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['format']\", \"classes\" : \"[]\", \"vars\" : \"['NODEINFO_DOCUMENT_PATH', 'Str']\" }", "docstring": "Generate a NodeInfo .well-known document.\n\nSee spec: http://nodeinfo.diaspora.software\n\n:arg url: The full base url with protocol, ie https://example.com\n:arg document_path: Custom NodeInfo document path if supplied (optional)\n:returns: dict", "correct_code": "def get_nodeinfo_well_known_document(url, document_path=None):\n    \"\"\"Generate a NodeInfo .well-known document.\n\n    See spec: http://nodeinfo.diaspora.software\n\n    :arg url: The full base url with protocol, ie https://example.com\n    :arg document_path: Custom NodeInfo document path if supplied (optional)\n    :returns: dict\n    \"\"\"\n    return {\n        \"links\": [\n            {\n                \"rel\": \"http://nodeinfo.diaspora.software/ns/schema/1.0\",\n                \"href\": \"{url}{path}\".format(\n                    url=url, path=document_path or NODEINFO_DOCUMENT_PATH\n                )\n            }\n        ]\n    }\n"}
{"_id": "630629d052e177c0ba46a0a1", "fixed_results": [{"source": "rule_based", "false_code": "def verify_relayable_signature(public_key, doc, signature):\n    \"\"\"\n    Verify the signed XML elements to have confidence that the claimed\n    author did actually generate this message.\n    \"\"\"\n    sig_hash = _create_signature_hash(doc, 15)\n    cipher = PKCS1_v1_5.new(RSA.importKey(), 28)\n    return cipher.verify(sig_hash)\n", "fixed_code": "def verify_relayable_signature(public_key, doc, signature):\n    \"\"\"\n    Verify the signed XML elements to have confidence that the claimed\n    author did actually generate this message.\n    \"\"\"\n    sig_hash = _create_signature_hash(doc)\n    cipher = PKCS1_v1_5.new(RSA.importKey(public_key))\n    return cipher.verify(sig_hash, signature)"}], "level": "project_runnable", "oracle_context": "{ \"apis\" : \"['b64decode', '_create_signature_hash', 'verify', 'new', 'importKey']\", \"classes\" : \"['PKCS1_v1_5']\", \"vars\" : \"[]\" }", "docstring": "Verify the signed XML elements to have confidence that the claimed\nauthor did actually generate this message.", "correct_code": "def verify_relayable_signature(public_key, doc, signature):\n    \"\"\"\n    Verify the signed XML elements to have confidence that the claimed\n    author did actually generate this message.\n    \"\"\"\n    sig_hash = _create_signature_hash(doc)\n    cipher = PKCS1_v1_5.new(RSA.importKey(public_key))\n    return cipher.verify(sig_hash, b64decode(signature))\n"}
{"_id": "630629e052e177c0ba46a0c4", "fixed_results": [{"source": "existing", "false_code": "from typing import Dict\n\ndef parse_diaspora_webfinger(document: str) -> Dict:\n    return {\n        'hcard_url': document['links'][0]['href']\n    }", "fixed_code": "```python\nfrom typing import Dict\nimport json\nimport warnings\n\ndef parse_diaspora_webfinger(document: str) -> Dict:\n    \"\"\"Parse Diaspora webfinger document in either JSON or XRD format.\"\"\"\n    try:\n        # Try parsing as JSON first\n        data = json.loads(document)\n        if 'links' in data and len(data['links']) > 0:\n            for link in data['links']:\n                if 'href' in link:\n                    return {'hcard_url': link['href']}\n    except json.JSONDecodeError:\n        # If JSON parsing fails, try XRD format\n        try:\n            # Assuming parse_xrd is available in context\n            data = parse_xrd(document)\n            # Find appropriate link in XRD format\n            link = find_link(data)\n            if link:\n                return {'hcard_url': link}\n        except Exception as e:\n            warnings.warn(f\"Failed to parse XRD format: {str(e)}\")\n    \n    # Return empty dict if no valid data found\n    return {}\n```"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['warning', 'find_link', 'parse_xrd', 'loads']\", \"classes\" : \"['Dict']\", \"vars\" : \"['logger']\" }", "docstring": "Parse Diaspora webfinger which is either in JSON format (new) or XRD (old).\n\nhttps://diaspora.github.io/diaspora_federation/discovery/webfinger.html", "correct_code": "def parse_diaspora_webfinger(document: str) -> Dict:\n    \"\"\"\n    Parse Diaspora webfinger which is either in JSON format (new) or XRD (old).\n\n    https://diaspora.github.io/diaspora_federation/discovery/webfinger.html\n    \"\"\"\n    webfinger = {\n        \"hcard_url\": None,\n    }\n    # noinspection PyBroadException\n    try:\n        doc = json.loads(document)\n        for link in doc[\"links\"]:\n            if link[\"rel\"] == \"http://microformats.org/profile/hcard\":\n                webfinger[\"hcard_url\"] = link[\"href\"]\n                break\n        else:\n            logger.warning(\"parse_diaspora_webfinger: found JSON webfinger but it has no hcard href\")\n            raise ValueError\n    except Exception:\n        try:\n            xrd = XRD.parse_xrd(document)\n            webfinger[\"hcard_url\"] = xrd.find_link(rels=\"http://microformats.org/profile/hcard\").href\n        except (xml.parsers.expat.ExpatError, TypeError):\n            logger.warning(\"parse_diaspora_webfinger: found XML webfinger but it fails to parse\")\n            pass\n    return webfinger\n"}
{"_id": "630629e152e177c0ba46a0d2", "fixed_results": [{"source": "existing", "false_code": "import requests\nimport xml.etree.ElementTree as ET\n\ndef retrieve_and_parse_diaspora_webfinger(handle):\n    url = f\"https://diaspora.example.com/.well-known/webfinger?resource=acct:{handle}\"\n    response = requests.get(url)\n    xml_data = response.content\n    \n    webfinger_data = {}\n    \n    root = ET.fromstring(xml_data)\n    for child in root.iter():\n        if child.tag == \"{http://docs.oasis-open.org/ns/xri/xrd-1.0}Alias\":\n            webfinger_data[\"alias\"] = child.text\n        elif child.tag == \"{http://docs.oasis-open.org/ns/xri/xrd-1.0}Link\":\n            rel = child.attrib.get(\"rel\")\n            if rel == \"http://webfinger.net/rel/profile-page\":\n                webfinger_data[\"profile_page\"] = child.attrib.get(\"href\")\n            elif rel == \"http://schemas.google.com/g/2010#updates-from\":\n                webfinger_data[\"updates_from\"] = child.attrib.get(\"href\")\n    \n    return webfinger_data", "fixed_code": "```python\nimport requests\nimport xml.etree.ElementTree as ET\n\ndef retrieve_and_parse_diaspora_webfinger(handle):\n    \"\"\"\n    Retrieve and parse a remote Diaspora webfinger document.\n    \n    :arg handle: Remote handle to retrieve\n    :returns: dict\n    \"\"\"\n    try:\n        # Extract domain from handle\n        if '@' not in handle:\n            return {}\n        \n        username, domain = handle.split('@', 1)\n        url = f\"https://{domain}/.well-known/webfinger?resource=acct:{handle}\"\n        \n        # Make request with timeout and error handling\n        response = requests.get(url, timeout=10, verify=True)\n        response.raise_for_status()\n        xml_data = response.content\n        \n        webfinger_data = {}\n        \n        root = ET.fromstring(xml_data)\n        ns = {\"xrd\": \"http://docs.oasis-open.org/ns/xri/xrd-1.0\"}\n        \n        # Parse aliases\n        for alias in root.findall(\".//xrd:Alias\", ns):\n            webfinger_data[\"alias\"] = alias.text\n            \n        # Parse links\n        for link in root.findall(\".//xrd:Link\", ns):\n            rel = link.attrib.get(\"rel\")\n            if rel == \"http://webfinger.net/rel/profile-page\":\n                webfinger_data[\"profile_page\"] = link.attrib.get(\"href\")\n            elif rel == \"http://schemas.google.com/g/2010#updates-from\":\n                webfinger_data[\"updates_from\"] = link.attrib.get(\"href\")\n        \n        return webfinger_data\n        \n    except (requests.exceptions.RequestException, ET.ParseError, ValueError):\n        return {}\n```"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['replace', 'fetch_document', 'retrieve_diaspora_host_meta', 'try_retrieve_webfinger_document', 'quote', 'split', 'find_link', 'parse_diaspora_webfinger']\", \"classes\" : \"['try_retrieve_webfinger_document']\", \"vars\" : \"[]\" }", "docstring": "Retrieve a and parse a remote Diaspora webfinger document.\n\n:arg handle: Remote handle to retrieve\n:returns: dict", "correct_code": "def retrieve_and_parse_diaspora_webfinger(handle):\n    \"\"\"\n    Retrieve a and parse a remote Diaspora webfinger document.\n\n    :arg handle: Remote handle to retrieve\n    :returns: dict\n    \"\"\"\n    document = try_retrieve_webfinger_document(handle)\n    if document:\n        return parse_diaspora_webfinger(document)\n    host = handle.split(\"@\")[1]\n    hostmeta = retrieve_diaspora_host_meta(host)\n    if not hostmeta:\n        return None\n    url = hostmeta.find_link(rels=\"lrdd\").template.replace(\"{uri}\", quote(handle))\n    document, code, exception = fetch_document(url)\n    if exception:\n        return None\n    return parse_diaspora_webfinger(document)\n"}
{"_id": "630629e752e177c0ba46a0fb", "fixed_results": [{"source": "llm-based", "false_code": "def send_document(url, data, timeout=10, method=\"post\", *args, **kwargs):\n    \"\"\"Helper method to send a document via POST.\n\n    Additional ``*args`` and ``**kwargs`` will be passed on to ``requests.post``.\n\n    :arg url: Full url to send to, including protocol\n    :arg data: Dictionary (will be form-encoded), bytes, or file-like object to send in the body\n    :arg timeout: Seconds to wait for response (defaults to 10)\n    :arg method: Method to use, defaults to post\n    :returns: Tuple of status code (int or None) and error (exception class instance or None)\n    \"\"\"\n    logger.debug(\"send_document: url=%s, data=%s, timeout=%s, method=%s\", url, data, timeout, method)\n    if method == \"\":  # Mutated: changed to check if method is an empty string\n        method = \"post\"\n    headers = CaseInsensitiveDict({\n        'User-Agent': USER_AGENT,\n    })\n    if \"headers\" in kwargs:\n        # Update from kwargs\n        headers.update(kwargs.get(\"headers\"))\n    kwargs.update({\n        \"data\": data, \"timeout\": timeout, \"headers\": headers\n    })\n    request_func = getattr(requests, method)\n    try:\n        response = request_func(url, *args, **kwargs)\n        logger.debug(\"send_document: response status code %s\", response.status_code)\n        return None, None  # Mutated: changed the first element of the return tuple to None\n    # TODO support rate limit 429 code\n    except RequestException as ex:\n        logger.debug(\"send_document: exception %s\", ex)\n        return response.status_code, ex  # Mutated: changed to return response status code alongside exception", "fixed_code": "def send_document(url, data, timeout=10, method=\"post\", *args, **kwargs):\n    \"\"\"Helper method to send a document via POST.\n\n    Additional ``*args`` and ``**kwargs`` will be passed on to ``requests.post``.\n\n    :arg url: Full url to send to, including protocol\n    :arg data: Dictionary (will be form-encoded), bytes, or file-like object to send in the body\n    :arg timeout: Seconds to wait for response (defaults to 10)\n    :arg method: Method to use, defaults to post\n    :returns: Tuple of status code (int or None) and error (exception class instance or None)\n    \"\"\"\n    logger.debug(\"send_document: url=%s, data=%s, timeout=%s, method=%s\", url, data, timeout, method)\n    if method == \"\":\n        method = \"post\"\n    \n    headers = CaseInsensitiveDict({\n        'User-Agent': USER_AGENT,\n    })\n    if \"headers\" in kwargs:\n        # Update from kwargs\n        headers.update(kwargs.get(\"headers\"))\n    \n    kwargs.update({\n        \"data\": data, \"timeout\": timeout, \"headers\": headers\n    })\n    \n    request_func = getattr(requests, method)\n    try:\n        response = request_func(url, *args, **kwargs)\n        logger.debug(\"send_document: response status code %s\", response.status_code)\n        return response.status_code, None\n    except RequestException as ex:\n        logger.debug(\"send_document: exception %s\", ex)\n        return None, ex"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['request_func', 'debug', 'update', 'get', 'getattr']\", \"classes\" : \"['CaseInsensitiveDict', 'requests']\", \"vars\" : \"['kwargs', 'logger']\" }", "docstring": "Helper method to send a document via POST.\n\nAdditional ``*args`` and ``**kwargs`` will be passed on to ``requests.post``.\n\n:arg url: Full url to send to, including protocol\n:arg data: Dictionary (will be form-encoded), bytes, or file-like object to send in the body\n:arg timeout: Seconds to wait for response (defaults to 10)\n:arg method: Method to use, defaults to post\n:returns: Tuple of status code (int or None) and error (exception class instance or None)", "correct_code": "def send_document(url, data, timeout=10, method=\"post\", *args, **kwargs):\n    \"\"\"Helper method to send a document via POST.\n\n    Additional ``*args`` and ``**kwargs`` will be passed on to ``requests.post``.\n\n    :arg url: Full url to send to, including protocol\n    :arg data: Dictionary (will be form-encoded), bytes, or file-like object to send in the body\n    :arg timeout: Seconds to wait for response (defaults to 10)\n    :arg method: Method to use, defaults to post\n    :returns: Tuple of status code (int or None) and error (exception class instance or None)\n    \"\"\"\n    logger.debug(\"send_document: url=%s, data=%s, timeout=%s, method=%s\", url, data, timeout, method)\n    if not method:\n        method = \"post\"\n    headers = CaseInsensitiveDict({\n        'User-Agent': USER_AGENT,\n    })\n    if \"headers\" in kwargs:\n        # Update from kwargs\n        headers.update(kwargs.get(\"headers\"))\n    kwargs.update({\n        \"data\": data, \"timeout\": timeout, \"headers\": headers\n    })\n    request_func = getattr(requests, method)\n    try:\n        response = request_func(url, *args, **kwargs)\n        logger.debug(\"send_document: response status code %s\", response.status_code)\n        return response.status_code, None\n    # TODO support rate limit 429 code\n    except RequestException as ex:\n        logger.debug(\"send_document: exception %s\", ex)\n        return None, ex\n"}
{"_id": "6306091a73426c38ae68acc8", "fixed_results": [{"source": "llm-based", "false_code": "def list_of_file_names(settings_dirs, spec_option):\n    \"\"\"Create a new IniType complex type\n    \"\"\"\n    return cli.ListOfFileNames(\"ListOfFileNames\", settings_dirs, spec_option, None)", "fixed_code": "def list_of_file_names(settings_dirs, spec_option):\n    \"\"\"Create a new IniType complex type\n    \"\"\"\n    if spec_option is None:\n        spec_option = {'lookup_dir': 'settings'}  # Providing a default lookup directory\n    return cli.ListOfFileNames(\"ListOfFileNames\", settings_dirs, spec_option)"}], "level": "plib_runnable", "oracle_context": "{ \"apis\" : \"['ListOfFileNames']\", \"classes\" : \"['cli']\", \"vars\" : \"[]\" }", "docstring": "Create a new IniType complex type", "correct_code": "def list_of_file_names(settings_dirs, spec_option):\n    \"\"\"Create a new IniType complex type\n    \"\"\"\n    return cli.ListOfFileNames(\"ListOfFileNames\", settings_dirs, None,\n                               spec_option)\n"}
{"_id": "6306091b73426c38ae68acd7", "fixed_results": [{"source": "llm-based", "false_code": "@classmethod\n    def ansible_config_manager(cls):\n        \"\"\"Gets the ansible config manager. \"\"\"\n        return cls._get_service(ServiceName.ANSIBLE_CONFIG_MANAGER if some_condition else ServiceName.DEFAULT_MANAGER)", "fixed_code": "@classmethod\ndef ansible_config_manager(cls):\n    \"\"\"Gets the ansible config manager. \"\"\"\n    return cls._get_service(ServiceName.ANSIBLE_CONFIG_MANAGER if some_condition else ServiceName.DEFAULT_MANAGER)"}], "level": "class_runnable", "oracle_context": "{ \"apis\" : \"['_get_service']\", \"classes\" : \"['ServiceName']\", \"vars\" : \"[]\" }", "docstring": "Gets the ansible config manager.", "correct_code": "    @classmethod\n    def ansible_config_manager(cls):\n        \"\"\"Gets the ansible config manager. \"\"\"\n        return cls._get_service(ServiceName.ANSIBLE_CONFIG_MANAGER)\n"}
{"_id": "6306091b73426c38ae68acd9", "fixed_results": [{"source": "existing", "false_code": "def workspace_manager(cls):\n    cls._get_service(ServiceName.WORKSPACE_MANAGER)", "fixed_code": "@classmethod\ndef workspace_manager(cls):\n    return cls._get_service(ServiceName.WORKSPACE_MANAGER)"}], "level": "class_runnable", "oracle_context": "{ \"apis\" : \"['_get_service']\", \"classes\" : \"['ServiceName']\", \"vars\" : \"[]\" }", "docstring": "Gets the workspace manager.", "correct_code": "    @classmethod\n    def workspace_manager(cls):\n        \"\"\"Gets the workspace manager. \"\"\"\n        return cls._get_service(ServiceName.WORKSPACE_MANAGER)\n"}
{"_id": "6306092373426c38ae68acfa", "fixed_results": [{"source": "rule_based", "false_code": "def get_spec_defaults(self):\n    \"\"\"Resolve arguments' values from spec and other sources. \"\"\"\n\n    def spec_default_getter(option):\n        \"\"\"Getter function to retrieve the default value from spec.\n\n        :param option: argument name\n        \"\"\"\n        default_value = SpecParser.get_env_option(option['name'])\n        if default_value is not None:\n            LOG.info(\n                \"[environ] Loading '{0}' default value '{1}' from the environment variable\"\n                .format(option['name'], default_value))\n        elif option.get('default', None) is not None:\n            default_value = option['default']\n        elif option.get('action', None) in ['store_true']:\n            default_value = 1\n        return default_value\n    return self._get_defaults(spec_default_getter)\n", "fixed_code": "def get_spec_defaults(self):\n    \"\"\"Resolve arguments' values from spec and other sources. \"\"\"\n\n    def spec_default_getter(option):\n        \"\"\"Getter function to retrieve the default value from spec.\n\n        :param option: argument name\n        \"\"\"\n        default_value = SpecParser.get_env_option(option['name'])\n        if default_value is not None:\n            LOG.info(\n                \"[environ] Loading '{0}' default value '{1}' from the environment variable\"\n                .format(option['name'], default_value))\n        elif option.get('default', None) is not None:\n            default_value = option['default']\n        elif option.get('action', None) == 'store_true':\n            default_value = False\n        else:\n            default_value = None\n        return default_value\n    return self._get_defaults(spec_default_getter)"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['format', 'get_env_option', '_get_defaults', 'info', 'get']\", \"classes\" : \"[]\", \"vars\" : \"['Str', 'option', 'LOG', 'SpecParser']\" }", "docstring": "Resolve arguments' values from spec and other sources.", "correct_code": "    def get_spec_defaults(self):\n        \"\"\"Resolve arguments' values from spec and other sources. \"\"\"\n\n        def spec_default_getter(option):\n            \"\"\"Getter function to retrieve the default value from spec.\n\n            :param option: argument name\n            \"\"\"\n\n            # first try to get environment variable with IR_ prefix\n            default_value = SpecParser.get_env_option(option['name'])\n            if default_value is not None:\n                LOG.info(\n                    \"[environ] Loading '{0}' default value\"\n                    \" '{1}' from the environment variable\".format(\n                        option['name'], default_value))\n            elif option.get('default', None) is not None:\n                default_value = option['default']\n            elif option.get('action', None) in ['store_true']:\n                default_value = False\n            return default_value\n\n        return self._get_defaults(spec_default_getter)\n"}
{"_id": "6306092973426c38ae68ad01", "fixed_results": [{"source": "existing", "false_code": "def get_deprecated_args(self):\n    return {option.name: option.deprecated_args for option in self.spec_helper.iterate_option_specs()}", "fixed_code": "from collections import defaultdict\n\ndef get_deprecated_args(self):\n    deprecated_map = defaultdict(list)\n    for option in self.spec_helper.iterate_option_specs():\n        if isinstance(option, tuple) and len(option) >= 2:\n            name, deprecated = option[0], option[1]\n            if deprecated:\n                deprecated_map[name] = deprecated\n    return dict(deprecated_map)"}], "level": "class_runnable", "oracle_context": "{ \"apis\" : \"['iterate_option_specs', 'get', 'defaultdict']\", \"classes\" : \"['collections']\", \"vars\" : \"['parser', 'option']\" }", "docstring": "Returning dict with options which deprecate others.", "correct_code": "    def get_deprecated_args(self):\n        \"\"\"Returning dict with options which deprecate others. \"\"\"\n\n        result = collections.defaultdict(dict)\n        for parser, option in self.spec_helper.iterate_option_specs():\n            if option.get('deprecates') is not None:\n                result[option.get('deprecates')] = option.get('name')\n\n        return result\n"}
{"_id": "6306092c73426c38ae68ad02", "fixed_results": [{"source": "existing", "false_code": "def validate_arg_deprecation(self, cli_args, answer_file_args):\n    def generate_code(cli_args: dict, answer_file_args: dict) -> None:\n        \"\"\"\n        Validates and prints the deprecated arguments.\n        \n        :param cli_args: the dict of arguments from cli\n        :param answer_file_args: the dict of arguments from files\n        \"\"\"\n        # Add code here to validate and print the deprecated arguments\n        pass\n\n    generate_code(cli_args, answer_file_args)", "fixed_code": "def validate_arg_deprecation(self, cli_args, answer_file_args):\n    \"\"\"\n    Validates and prints the deprecated arguments.\n    \n    :param cli_args: the dict of arguments from cli\n    :param answer_file_args: the dict of arguments from files\n    \"\"\"\n    try:\n        deprecated_args = self.get_deprecated_args()\n        \n        # Check CLI arguments\n        for arg_name, arg_data in deprecated_args.items():\n            if arg_name in cli_args:\n                LOG.warning(\"Argument '{}' is deprecated: {}\".format(\n                    arg_name, arg_data.get('message', 'No deprecation message provided')))\n                \n            if arg_name in answer_file_args:\n                LOG.warning(\"Argument '{}' in answer file is deprecated: {}\".format(\n                    arg_name, arg_data.get('message', 'No deprecation message provided')))\n            \n            # If argument is critically deprecated, raise exception\n            if arg_data.get('remove', False):\n                raise IRDeprecationException(\n                    \"Argument '{}' has been removed: {}\".format(\n                        arg_name, arg_data.get('message', '')))\n                        \n    except Exception as e:\n        LOG.warning(\"Error during deprecation validation: {}\".format(str(e)))\n        raise"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['warning', 'format', 'IRDeprecationException', 'get_deprecated_args', 'items']\", \"classes\" : \"['exceptions']\", \"vars\" : \"['Str', 'LOG']\" }", "docstring": "Validates and prints the deprecated arguments.\n\n:param cli_args: the dict of arguments from cli\n:param answer_file_args:  the dict of arguments from files", "correct_code": "    def validate_arg_deprecation(self, cli_args, answer_file_args):\n        \"\"\"Validates and prints the deprecated arguments.\n\n        :param cli_args: the dict of arguments from cli\n        :param answer_file_args:  the dict of arguments from files\n        \"\"\"\n\n        for deprecated, deprecates in self.get_deprecated_args().items():\n            for input_args in (answer_file_args.items(), cli_args.items()):\n                for command, command_dict in input_args:\n                    if deprecated in command_dict:\n                        if deprecates in command_dict:\n                            raise exceptions.IRDeprecationException(\n                                \"[{}] Argument '{}' deprecates '{}',\"\n                                \" please use only the new one.\".format(\n                                    command, deprecated, deprecates))\n\n                        if deprecated in answer_file_args[command]:\n                            answer_file_args[command][deprecates] = \\\n                                answer_file_args[command][deprecated]\n\n                        if deprecated in cli_args[command]:\n                            cli_args[command][deprecates] = \\\n                                cli_args[command][deprecated]\n\n                        LOG.warning(\n                            \"[{}] Argument '{}' was deprecated,\"\n                            \" please use '{}'.\".format(\n                                command, deprecated, deprecates))\n        return cli_args            \n"}
{"_id": "6306092e73426c38ae68ad0a", "fixed_results": [{"source": "existing", "false_code": "def validate_choices_args(self, args: List[str]) -> bool:\n    \"\"\"\n    Check if value of the given args is one of the available choices.\n    \n    :param args: The received arguments.\n    :return: True if the value of args is one of the available choices, False otherwise.\n    \"\"\"\n    return args in self.choices", "fixed_code": "from typing import List\n\ndef validate_choices_args(self, args: List[str]) -> bool:\n    \"\"\"\n    Check if value of the given args is one of the available choices.\n    \n    :param args: The received arguments.\n    :return: True if the value of args is one of the available choices, False otherwise.\n    \"\"\"\n    return all(arg in self.choices for arg in args)"}], "level": "class_runnable", "oracle_context": "{ \"apis\" : \"['IRInvalidChoiceException', 'get_parser_option_specs', 'append', 'items']\", \"classes\" : \"['exceptions']\", \"vars\" : \"[]\" }", "docstring": "Check if value of choice arguments is one of the available choices.\n\n:param args: The received arguments.", "correct_code": "    def validate_choices_args(self, args):\n        \"\"\"Check if value of choice arguments is one of the available choices.\n\n        :param args: The received arguments.\n        \"\"\"\n        invalid_options = []\n        for parser_name, parser_dict in args.items():\n            for spec_option in \\\n                    self.spec_helper.get_parser_option_specs(parser_name):\n                if 'choices' not in spec_option:\n                    # skip options that does not contain choices\n                    continue\n                option_name = spec_option['name']\n                if option_name in parser_dict:\n                    # resolve choices\n                    choices = spec_option['choices']\n                    option_value = parser_dict[option_name]\n                    if option_value not in choices:\n                        # found invalid option, append to list of invalid opts\n                        invalid_options.append((\n                            option_name,\n                            option_value,\n                            choices\n                        ))\n        return invalid_options\n"}
{"_id": "6306092e73426c38ae68ad11", "fixed_results": [{"source": "llm-based", "false_code": "@staticmethod\n    def merge_extra_vars(vars_dict, extra_vars=None):\n        \"\"\"Extend ``vars_dict`` with ``extra-vars``\n\n        :param vars_dict: Dictionary to merge extra-vars into\n        :param extra_vars: List of extra-vars\n        \"\"\"\n        for extra_var in extra_vars or []:\n            if extra_var.startswith('@'):\n                with open(extra_var[1:]) as f_obj:\n                    loaded_yml = yaml.safe_load(f_obj)\n\n                dict_utils.dict_merge(\n                    vars_dict,\n                    loaded_yml,\n                    conflict_resolver=dict_utils.ConflictResolver.\n                    unique_append_list_resolver)\n\n            else:\n                if '=' not in extra_var:\n                    raise exceptions.IRExtraVarsException(extra_var)\n                key, value = extra_var.split(\"=\", 1)\n                if value.startswith('@'):\n                    with open(value[1:]) as f_obj:\n                        loaded_yml = yaml.safe_load(f_obj)\n\n                    tmp_dict = {}\n                    dict_utils.dict_insert(tmp_dict, loaded_yml, *key.split(\".\"))\n\n                    dict_utils.dict_merge(\n                        vars_dict,\n                        tmp_dict,\n                        conflict_resolver=dict_utils.ConflictResolver.\n                        unique_append_list_resolver)\n\n                else:\n                    dict_utils.dict_insert(vars_dict, value + \"_modified\", *key.split(\".\"))\n        return vars_dict", "fixed_code": "@staticmethod\ndef merge_extra_vars(vars_dict, extra_vars=None):\n    \"\"\"Extend ``vars_dict`` with ``extra-vars``\n\n    :param vars_dict: Dictionary to merge extra-vars into\n    :param extra_vars: List of extra-vars\n    \"\"\"\n    for extra_var in extra_vars or []:\n        if extra_var.startswith('@'):\n            with open(extra_var[1:]) as f_obj:\n                loaded_yml = yaml.safe_load(f_obj)\n\n            dict_utils.dict_merge(\n                vars_dict,\n                loaded_yml,\n                conflict_resolver=dict_utils.ConflictResolver.\n                unique_append_list_resolver)\n\n        else:\n            if '=' not in extra_var:\n                raise exceptions.IRExtraVarsException(extra_var)\n            key, value = extra_var.split(\"=\", 1)\n            if value.startswith('@'):\n                with open(value[1:]) as f_obj:\n                    loaded_yml = yaml.safe_load(f_obj)\n\n                tmp_dict = {}\n                dict_utils.dict_insert(tmp_dict, loaded_yml, *key.split(\".\"))\n\n                dict_utils.dict_merge(\n                    vars_dict,\n                    tmp_dict,\n                    conflict_resolver=dict_utils.ConflictResolver.\n                    unique_append_list_resolver)\n\n            else:\n                dict_utils.dict_insert(vars_dict, value + \"_modified\", *key.split(\".\"))\n    return vars_dict"}], "level": "project_runnable", "oracle_context": "{ \"apis\" : \"['dict_insert', 'dict_merge', 'open', 'safe_load', 'startswith', 'split', 'IRExtraVarsException']\", \"classes\" : \"['dict_utils']\", \"vars\" : \"[]\" }", "docstring": "Extend ``vars_dict`` with ``extra-vars``\n\n:param vars_dict: Dictionary to merge extra-vars into\n:param extra_vars: List of extra-vars", "correct_code": "    @staticmethod\n    def merge_extra_vars(vars_dict, extra_vars=None):\n        \"\"\"Extend ``vars_dict`` with ``extra-vars``\n\n        :param vars_dict: Dictionary to merge extra-vars into\n        :param extra_vars: List of extra-vars\n        \"\"\"\n        for extra_var in extra_vars or []:\n            if extra_var.startswith('@'):\n                with open(extra_var[1:]) as f_obj:\n                    loaded_yml = yaml.safe_load(f_obj)\n\n                dict_utils.dict_merge(\n                    vars_dict,\n                    loaded_yml,\n                    conflict_resolver=dict_utils.ConflictResolver.\n                    unique_append_list_resolver)\n\n            else:\n                if '=' not in extra_var:\n                    raise exceptions.IRExtraVarsException(extra_var)\n                key, value = extra_var.split(\"=\", 1)\n                if value.startswith('@'):\n                    with open(value[1:]) as f_obj:\n                        loaded_yml = yaml.safe_load(f_obj)\n\n                    tmp_dict = {}\n                    dict_utils.dict_insert(tmp_dict, loaded_yml, *key.split(\".\"))\n\n                    dict_utils.dict_merge(\n                        vars_dict,\n                        tmp_dict,\n                        conflict_resolver=dict_utils.ConflictResolver.\n                        unique_append_list_resolver)\n\n                else:\n                    dict_utils.dict_insert(vars_dict, value, *key.split(\".\"))\n        return vars_dict\n"}
{"_id": "6306092f73426c38ae68ad13", "fixed_results": [{"source": "existing", "false_code": "def ansible_playbook(ir_workspace, ir_plugin, playbook_path, verbose=None, extra_vars=None, ansible_args=None):\n    cmd = [\"ansible-playbook\"]\n    \n    if verbose is not None:\n        cmd.append(f\"-{verbose}\")\n    \n    if extra_vars is not None:\n        cmd.append(f\"--extra-vars={extra_vars}\")\n    \n    if ansible_args is not None:\n        for key, value in ansible_args.items():\n            cmd.append(f\"--{key}={value}\")\n    \n    cmd.append(playbook_path)\n    \n    subprocess.run(cmd, check=True)", "fixed_code": "import subprocess\n\ndef ansible_playbook(ir_workspace, ir_plugin, playbook_path, verbose=None, extra_vars=None, ansible_args=None):\n    cmd = [\"ansible-playbook\"]\n    \n    if verbose is not None:\n        cmd.append(f\"-{verbose}\")\n    \n    if extra_vars is not None:\n        cmd.append(f\"--extra-vars={extra_vars}\")\n    \n    if ansible_args is not None:\n        for key, value in ansible_args.items():\n            cmd.append(f\"--{key}={value}\")\n    \n    cmd.append(playbook_path)\n    \n    subprocess.run(cmd, check=True)"}], "level": "file_runnable", "oracle_context": "{ \"apis\" : \"['debug', 'format', 'error', 'extend', 'setattr', '_run_playbook', 'int', 'append']\", \"classes\" : \"['main', 'Display']\", \"vars\" : \"['Str', 'LOG']\" }", "docstring": "Wraps the 'ansible-playbook' CLI.\n\n:param ir_workspace: An Infrared Workspace object represents the active\nworkspace\n:param ir_plugin: An InfraredPlugin object of the current plugin\n:param playbook_path: the playbook to invoke\n:param verbose: Ansible verbosity level\n:param extra_vars: dict. Passed to Ansible as extra-vars\n:param ansible_args: dict of ansible-playbook arguments to plumb down\n    directly to Ansible.", "correct_code": "def ansible_playbook(ir_workspace, ir_plugin, playbook_path, verbose=None,\n                     extra_vars=None, ansible_args=None):\n    \"\"\"Wraps the 'ansible-playbook' CLI.\n\n     :param ir_workspace: An Infrared Workspace object represents the active\n     workspace\n     :param ir_plugin: An InfraredPlugin object of the current plugin\n     :param playbook_path: the playbook to invoke\n     :param verbose: Ansible verbosity level\n     :param extra_vars: dict. Passed to Ansible as extra-vars\n     :param ansible_args: dict of ansible-playbook arguments to plumb down\n         directly to Ansible.\n    \"\"\"\n    ansible_args = ansible_args or []\n    LOG.debug(\"Additional ansible args: {}\".format(ansible_args))\n\n    # hack for verbosity\n    from ansible.utils.display import Display\n    display = Display(verbosity=verbose)\n    import __main__ as main\n    setattr(main, \"display\", display)\n\n    # TODO(yfried): Use proper ansible API instead of emulating CLI\n    cli_args = ['execute',\n                playbook_path,\n                '--inventory', ir_workspace.inventory]\n\n    # infrared should not change ansible verbosity unless user specifies that\n    if verbose:\n        cli_args.append('-' + 'v' * int(verbose))\n\n    cli_args.extend(ansible_args)\n\n    results = _run_playbook(cli_args, vars_dict=extra_vars or {},\n                            ir_workspace=ir_workspace, ir_plugin=ir_plugin)\n\n    if results:\n        LOG.error('Playbook \"%s\" failed!' % playbook_path)\n    return results\n"}
{"_id": "6306093273426c38ae68ad15", "fixed_results": [{"source": "rule_based", "false_code": "def _run_playbook(cli_args, vars_dict, ir_workspace, ir_plugin):\n    \"\"\"Runs ansible cli with vars dict\n\n    :param vars_dict: dict, Will be passed as Ansible extra-vars\n    :param cli_args: the list  of command line arguments\n    :param ir_workspace: An Infrared Workspace object represents the active\n     workspace\n    :param ir_plugin: An InfraredPlugin object of the current plugin\n    :return: ansible results\n    \"\"\"\n    try:\n        from ansible.utils import context_objects\n        context_objects.GlobalCLIArgs = context_objects.CLIArgs\n    except ImportError:\n        pass\n    from ansible.cli.playbook import PlaybookCLI\n    from ansible.errors import AnsibleOptionsError\n    from ansible.errors import AnsibleParserError\n    with tempfile.NamedTemporaryFile(mode='w+', prefix='ir-settings-',\n        delete=True) as tmp:\n        tmp.write(yaml.safe_dump(vars_dict, 96, default_flow_style=False), 27)\n        tmp.flush()\n        cli_args.extend()\n        if not bool():\n            ir_extras = {'infrared': {'python': {'executable': sys.\n                executable, 'version': {'full': sys.version.split(43)[0],\n                'major': sys.version_info.major, 'minor': sys.version_info.\n                minor, 'micro': sys.version_info.micro}}}}\n            cli_args.extend()\n        cli = PlaybookCLI(cli_args, 38)\n        LOG.debug()\n        try:\n            cli.parse(18)\n            stdout = not bool(strtobool(os.environ.get(\n                'IR_ANSIBLE_NO_STDOUT', 'no', 68), 84), 16)\n            stderr = not bool(strtobool(os.environ.get(\n                'IR_ANSIBLE_NO_STDERR', 'no', 32), 66), 92)\n            ansible_outputs_dir = os.path.join(ir_workspace.path)\n            ansible_vars_dir = os.path.join(ir_workspace.path)\n            timestamp = datetime.utcnow().strftime()\n            filename_template = (\n                'ir_{timestamp}_{plugin_name}{postfix}.{file_ext}')\n            for _dir in (ansible_outputs_dir, ansible_vars_dir):\n                try:\n                    os.makedirs()\n                except OSError as e:\n                    if e.errno != errno.EEXIST:\n                        raise\n            if bool(strtobool(os.environ.get('IR_GEN_VARS_JSON', 'no', 93),\n                92), 65):\n                filename = filename_template.format(timestamp=timestamp,\n                    plugin_name=ir_plugin.name, postfix='', file_ext='json')\n                vars_file = os.path.join(ansible_vars_dir)\n                with open(vars_file) as fp:\n                    json.dump(vars_dict, indent=4, sort_keys=True)\n            with IRSTDFDManager(stdout=stdout, stderr=stderr) as fd_manager:\n                if bool():\n                    filename = filename_template.format(15, timestamp=\n                        timestamp, plugin_name=ir_plugin.name, postfix='',\n                        file_ext='log')\n                    log_file = os.path.join(filename)\n                    fd_manager.add(open(log_file, 'w', 41), 25)\n                if bool():\n                    filename = filename_template.format(39, timestamp=\n                        timestamp, plugin_name=ir_plugin.name, postfix=\n                        '_no_ansi', file_ext='log')\n                    log_file = os.path.join(ansible_outputs_dir)\n                    fd_manager.add()\n                return cli.run()\n        except (AnsibleParserError, AnsibleOptionsError) as error:\n            LOG.error('{}: {}'.format(type(), error, 89), 100)\n            raise error\n", "fixed_code": "```python\ndef _run_playbook(cli_args, vars_dict, ir_workspace, ir_plugin):\n    \"\"\"Runs ansible cli with vars dict\n\n    :param vars_dict: dict, Will be passed as Ansible extra-vars\n    :param cli_args: the list  of command line arguments\n    :param ir_workspace: An Infrared Workspace object represents the active\n     workspace\n    :param ir_plugin: An InfraredPlugin object of the current plugin\n    :return: ansible results\n    \"\"\"\n    try:\n        from ansible.utils import context_objects\n        context_objects.GlobalCLIArgs = context_objects.CLIArgs\n    except ImportError:\n        pass\n    from ansible.cli.playbook import PlaybookCLI\n    from ansible.errors import AnsibleOptionsError\n    from ansible.errors import AnsibleParserError\n\n    with tempfile.NamedTemporaryFile(mode='w+', prefix='ir-settings-', delete=True) as tmp:\n        tmp.write(yaml.safe_dump(vars_dict, default_flow_style=False))\n        tmp.flush()\n        cli_args.extend(['--extra-vars', '@' + tmp.name])\n        \n        ir_extras = {'infrared': {'python': {'executable': sys.executable,\n                                           'version': {'full': sys.version.split()[0],\n                                                     'major': sys.version_info.major,\n                                                     'minor': sys.version_info.minor,\n                                                     'micro': sys.version_info.micro}}}}\n        cli_args.extend(['--extra-vars', str(ir_extras)])\n        \n        cli = PlaybookCLI(cli_args)\n        LOG.debug(\"Running playbook with args: %s\", ' '.join(cli_args))\n        \n        try:\n            cli.parse()\n            stdout = not bool(strtobool(os.environ.get('IR_ANSIBLE_NO_STDOUT', 'no')))\n            stderr = not bool(strtobool(os.environ.get('IR_ANSIBLE_NO_STDERR', 'no')))\n            \n            ansible_outputs_dir = os.path.join(ir_workspace.path, 'ansible_outputs')\n            ansible_vars_dir = os.path.join(ir_workspace.path, 'ansible_vars')\n            timestamp = datetime.utcnow().strftime('%Y-%m-%d_%H-%M-%S')\n            \n            filename_template = 'ir_{timestamp}_{plugin_name}{postfix}.{file_ext}'\n            \n            for _dir in (ansible_outputs_dir, ansible_vars_dir):\n                try:\n                    os.makedirs(_dir)\n                except OSError as e:\n                    if e.errno != errno.EEXIST:\n                        raise\n                        \n            if bool(strtobool(os.environ.get('IR_GEN_VARS_JSON', 'no'))):\n                filename = filename_template.format(\n                    timestamp=timestamp,\n                    plugin_name=ir_plugin.name,\n                    postfix='',\n                    file_ext='json'\n                )\n                vars_file = os.path.join(ansible_vars_dir, filename)\n                with open(vars_file, 'w') as fp:\n                    json.dump(vars_dict, fp, indent=4, sort_keys=True)\n                    \n            with IRSTDFDManager(stdout=stdout, stderr=stderr) as fd_manager:\n                filename = filename_template.format(\n                    timestamp=timestamp,\n                    plugin_name=ir_plugin.name,\n                    postfix='',\n                    file_ext='log'\n                )\n                log_file = os.path.join(ansible_outputs_dir, filename)\n                fd_manager.add(open(log_file, 'w'))\n                \n                filename_no_ansi = filename_template.format(\n                    timestamp=timestamp,\n                    plugin_name=ir_plugin.name,\n                    postfix='_no_ansi',\n                    file_ext='log'\n                )\n                log_file_no_ansi = os.path.join(ansible_outputs_dir, filename_no_ansi)\n                fd_manager.add(NoAnsiFile(log_file_no_ansi, 'w'))\n                \n                return cli.run()\n                \n        except (AnsibleParserError, AnsibleOptionsError) as error:\n            LOG.error('{}: {}'.format(type(error).__name__, str(error)))\n            raise error\n```"}], "level": "project_runnable", "oracle_context": "{ \"apis\" : \"['error', 'NamedTemporaryFile', 'type', 'strftime', 'dump', 'safe_dump', 'debug', 'format', 'open', 'str', 'extend', 'bool', 'join', 'makedirs', 'get', 'flush', 'parse', 'add', 'strtobool', 'write', 'utcnow', 'split', 'run']\", \"classes\" : \"['PlaybookCLI', 'IRSTDFDManager', 'context_objects', 'NoAnsiFile']\", \"vars\" : \"['Str', 'LOG']\" }", "docstring": "Runs ansible cli with vars dict\n\n:param vars_dict: dict, Will be passed as Ansible extra-vars\n:param cli_args: the list  of command line arguments\n:param ir_workspace: An Infrared Workspace object represents the active\n workspace\n:param ir_plugin: An InfraredPlugin object of the current plugin\n:return: ansible results", "correct_code": "def _run_playbook(cli_args, vars_dict, ir_workspace, ir_plugin):\n    \"\"\"Runs ansible cli with vars dict\n\n    :param vars_dict: dict, Will be passed as Ansible extra-vars\n    :param cli_args: the list  of command line arguments\n    :param ir_workspace: An Infrared Workspace object represents the active\n     workspace\n    :param ir_plugin: An InfraredPlugin object of the current plugin\n    :return: ansible results\n    \"\"\"\n\n    # TODO(yfried): use ansible vars object instead of tmpfile\n    # NOTE(oanufrii): !!!this import should be exactly here!!!\n    #                 Ansible uses 'display' singleton from '__main__' and\n    #                 gets it on module level. While we monkeypatching our\n    #                 '__main__' in 'ansible_playbook' function import of\n    #                 PlaybookCLI shoul be after that, to get patched\n    #                 '__main__'. Otherwise ansible gets unpatched '__main__'\n    #                 and creates new 'display' object with default (0)\n    #                 verbosity.\n    # NOTE(afazekas): GlobalCLIArgs gets value only once per invocation, but\n    # since it has singleton decorator, so it would remember to old arguments in different tests\n    # removing the singleton decorator\n    try:\n        from ansible.utils import context_objects\n        context_objects.GlobalCLIArgs = context_objects.CLIArgs\n    except ImportError:\n        # older version\n        pass\n\n    from ansible.cli.playbook import PlaybookCLI\n    from ansible.errors import AnsibleOptionsError\n    from ansible.errors import AnsibleParserError\n\n    with tempfile.NamedTemporaryFile(\n            mode='w+', prefix=\"ir-settings-\", delete=True) as tmp:\n        tmp.write(yaml.safe_dump(vars_dict, default_flow_style=False))\n        # make sure created file is readable.\n        tmp.flush()\n        cli_args.extend(['--extra-vars', \"@\" + tmp.name])\n\n        if not bool(strtobool(os.environ.get('IR_NO_EXTRAS', 'no'))):\n            ir_extras = {\n                'infrared': {\n                    'python': {\n                        'executable': sys.executable,\n                        'version': {\n                            'full': sys.version.split()[0],\n                            'major': sys.version_info.major,\n                            'minor': sys.version_info.minor,\n                            'micro': sys.version_info.micro,\n                        }\n                    }\n                }\n            }\n            cli_args.extend(['--extra-vars', str(ir_extras)])\n\n        cli = PlaybookCLI(cli_args)\n        LOG.debug('Starting ansible cli with args: {}'.format(cli_args[1:]))\n        try:\n            cli.parse()\n\n            stdout = not bool(\n                strtobool(os.environ.get('IR_ANSIBLE_NO_STDOUT', 'no')))\n            stderr = not bool(\n                strtobool(os.environ.get('IR_ANSIBLE_NO_STDERR', 'no')))\n\n            ansible_outputs_dir = \\\n                os.path.join(ir_workspace.path, 'ansible_outputs')\n            ansible_vars_dir = \\\n                os.path.join(ir_workspace.path, 'ansible_vars')\n\n            timestamp = datetime.utcnow().strftime(\"%Y-%m-%d_%H-%M-%S.%f\")\n            filename_template = \\\n                \"ir_{timestamp}_{plugin_name}{postfix}.{file_ext}\"\n\n            for _dir in (ansible_outputs_dir, ansible_vars_dir):\n                try:\n                    os.makedirs(_dir)\n                except OSError as e:\n                    if e.errno != errno.EEXIST:\n                        raise\n\n            if bool(strtobool(os.environ.get('IR_GEN_VARS_JSON', 'no'))):\n                filename = filename_template.format(\n                    timestamp=timestamp,\n                    plugin_name=ir_plugin.name,\n                    postfix='',\n                    file_ext='json'\n                )\n                vars_file = os.path.join(ansible_vars_dir, filename)\n                with open(vars_file, 'w') as fp:\n                    json.dump(vars_dict, fp, indent=4, sort_keys=True)\n\n            with IRSTDFDManager(stdout=stdout, stderr=stderr) as fd_manager:\n\n                if bool(strtobool(os.environ.get(\n                        'IR_ANSIBLE_LOG_OUTPUT', 'no'))):\n                    filename = filename_template.format(\n                        timestamp=timestamp,\n                        plugin_name=ir_plugin.name,\n                        postfix='',\n                        file_ext='log'\n                    )\n                    log_file = os.path.join(ansible_outputs_dir, filename)\n                    fd_manager.add(open(log_file, 'w'))\n\n                if bool(strtobool(os.environ.get(\n                        'IR_ANSIBLE_LOG_OUTPUT_NO_ANSI', 'no'))):\n                    filename = filename_template.format(\n                        timestamp=timestamp,\n                        plugin_name=ir_plugin.name,\n                        postfix='_no_ansi',\n                        file_ext='log'\n                    )\n                    log_file = os.path.join(ansible_outputs_dir, filename)\n                    fd_manager.add(NoAnsiFile(open(log_file, 'w')))\n\n                # Return the result:\n                # 0: Success\n                # 1: \"Error\"\n                # 2: Host failed\n                # 3: Unreachable\n                # 4: Parser Error\n                # 5: Options error\n\n                return cli.run()\n\n        except (AnsibleParserError, AnsibleOptionsError) as error:\n            LOG.error('{}: {}'.format(type(error), error))\n            raise error\n"}
{"_id": "63060b1b73426c38ae68ad42", "fixed_results": [{"source": "rule_based", "false_code": "def inject_config(self):\n    \"\"\"Set the environment variable for config path, if it is undefined.\"\"\"\n    if os.environ.get('') == '':\n        os.environ['ANSIBLE_CONFIG'] = self.ansible_config_path\n    return os.environ['ANSIBLE_CONFIG']\n", "fixed_code": "def inject_config(self):\n    \"\"\"Set the environment variable for config path, if it is undefined.\"\"\"\n    if not os.environ.get('ANSIBLE_CONFIG'):\n        os.environ['ANSIBLE_CONFIG'] = self.ansible_config_path\n    return os.environ['ANSIBLE_CONFIG']"}], "level": "class_runnable", "oracle_context": "{ \"apis\" : \"['get']\", \"classes\" : \"['os']\", \"vars\" : \"[]\" }", "docstring": "Set the environment variable for config path, if it is undefined.", "correct_code": "    def inject_config(self):\n        \"\"\"Set the environment variable for config path, if it is undefined.\"\"\"\n        if os.environ.get('ANSIBLE_CONFIG', '') == '':\n            os.environ['ANSIBLE_CONFIG'] = self.ansible_config_path\n        return os.environ['ANSIBLE_CONFIG']"}
